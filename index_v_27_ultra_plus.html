<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Prediksi Pertandingan - v29 Tactical Elite Ultra+</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
 body{font-family:Arial,Helvetica,sans-serif;margin:18px;background:#121212;color:#f5f5f5}
 h1{font-size:20px}
 .grid{display:grid;grid-template-columns:1fr 440px;gap:12px}
 .block{padding:10px;border-radius:8px;border:1px solid #333;background:#1e1e1e}
 label{display:block;font-size:13px;margin:6px 0}
 input[type="number"],input[type="text"]{width:100%;padding:6px;border:1px solid #555;border-radius:6px;background:#222;color:#fff}
 button{padding:8px 12px;border-radius:8px;border:0;background:#0b74de;color:#fff;cursor:pointer;margin:3px}
 .result{white-space:pre-wrap;font-family:monospace;background:#181818;padding:10px;border-radius:8px;border:1px dashed #444}
 table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
 th,td{padding:6px;border-bottom:1px solid #333;text-align:center}
 th{background:#222}
 .small{font-size:12px;color:#aaa}
 .bar{display:inline-block;height:10px;border-radius:3px;margin-left:6px;vertical-align:middle}
 .bar.over{background:#1e90ff}
 .bar.under{background:#ff4040}
 .bar.neutral{background:#777}
 .ind-small{display:inline-block;padding:2px 6px;border-radius:6px;font-size:12px;margin-left:8px}
 .ind-strong{background:#173d2b;color:#caffdd}
 .ind-mid{background:#b8860b;color:#fff7d1}
 .ind-weak{background:#5a1d1d;color:#ffd6d6}
 .tooltip{position:relative;display:inline-block}
 .tooltip .tooltiptext{visibility:hidden;width:220px;background:#222;color:#fff;text-align:left;border-radius:6px;padding:8px;position:absolute;z-index:1;bottom:125%;left:50%;transform:translateX(-50%);opacity:0;transition:opacity .2s}
 .tooltip:hover .tooltiptext{visibility:visible;opacity:1}
</style>
</head>
<body>
<h1>⚽ Prediksi — v29 Tactical Elite Ultra+</h1>
<p class="small">Auto Tackles+Interceptions (Home & Away) • DF injury adjust • Color defense indicator • Dual HDP & OU • Monte Carlo Lognormal</p>

<div class="grid">
 <div>
  <div class="block">
   <h3>Input Data Tim</h3>
   <label>Home Team: <input id="teamHome" type="text" value="Home FC"></label>
   <label>Away Team: <input id="teamAway" type="text" value="Away FC"></label>

   <label>xG per Game: <input id="xgHome" type="number" step="0.01"> <input id="xgAway" type="number" step="0.01"></label>
   <label>Shots on Target per Game: <input id="sotHome" type="number" step="0.1"> <input id="sotAway" type="number" step="0.1"></label>
   <label>Conversion Rate (0-1): <input id="convHome" type="number" step="0.01"> <input id="convAway" type="number" step="0.01"></label>
   <label>Big Chances / Missed: <input id="bigHome" type="number" step="0.1"> <input id="missHome" type="number" step="0.1"><br><input id="bigAway" type="number" step="0.1"> <input id="missAway" type="number" step="0.1"></label>

   <label>Goals Conceded per Game: <input id="gcHome" type="number" step="0.1"> <input id="gcAway" type="number" step="0.1"></label>
   <label>Saves per Game: <input id="saveHome" type="number" step="0.1"> <input id="saveAway" type="number" step="0.1"></label>

   <h4>Tackles & Interceptions (diisi terpisah — otomatis dijumlahkan)</h4>
   <label>Tackles per Game (Home): <input id="tackleHome" type="number" step="0.1" placeholder="mis. 18.3"> 
    Interceptions per Game (Home): <input id="interHome" type="number" step="0.1" placeholder="mis. 8.7"> 
    <span id="totalHomeDisplay" class="ind-small">Total: -</span>
    <span class="tooltip">ℹ️<span class="tooltiptext">Total = tackles + interceptions. Jika ada ≥2 DF absen, total otomatis dikurangi 15%.</span></span>
   </label>

   <label>Tackles per Game (Away): <input id="tackleAway" type="number" step="0.1" placeholder="mis. 15.2"> 
    Interceptions per Game (Away): <input id="interAway" type="number" step="0.1" placeholder="mis. 7.8"> 
    <span id="totalAwayDisplay" class="ind-small">Total: -</span>
    <span class="tooltip">ℹ️<span class="tooltiptext">Total = tackles + interceptions. Jika ada ≥2 DF absen, total otomatis dikurangi 15%.</span></span>
   </label>

   <label>Possession %: <input id="possHome" type="number" step="0.1"> <input id="possAway" type="number" step="0.1"></label>
   <label>Errors leading to goal per season (est): <input id="errHome" type="number" step="0.1"> <input id="errAway" type="number" step="0.1"></label>

   <h4>Pemain Absen (posisi saja, pisah koma)</h4>
   <label>Home (posisi): <input id="injHome" type="text" placeholder="GK, DF, DF, FW"></label>
   <label>Away (posisi): <input id="injAway" type="text" placeholder="MF, FW"></label>

   <label>ELO Rating: <input id="eloHome" type="number"> <input id="eloAway" type="number"></label>
   <label>Monte Carlo runs: <input id="mcRuns" type="number" value="3000" step="100"></label>
   <label>Correlation rho: <input id="rho" type="number" step="0.01" value="0.12"></label>
   <label>Dispersion Sigma (0.25–0.5): <input id="dispersionSigma" type="number" step="0.01" value="0.30"></label>

   <h4>Pasaran Handicap (HDP) — dua pasaran (Open & Now)</h4>
   <label>HDP1 Line: <input id="hdp1Line" type="text" value="-0.25"></label>
   <label>HDP1 Home Open <input id="hdp1HomeOpen" type="number" step="0.01"> Home Now <input id="hdp1HomeNow" type="number" step="0.01"><br>Away Open <input id="hdp1AwayOpen" type="number" step="0.01"> Away Now <input id="hdp1AwayNow" type="number" step="0.01"></label>

   <label>HDP2 Line: <input id="hdp2Line" type="text" value="-0.5"></label>
   <label>HDP2 Home Open <input id="hdp2HomeOpen" type="number" step="0.01"> Home Now <input id="hdp2HomeNow" type="number" step="0.01"><br>Away Open <input id="hdp2AwayOpen" type="number" step="0.01"> Away Now <input id="hdp2AwayNow" type="number" step="0.01"></label>

   <h4>Pasaran Over/Under — dua pasaran</h4>
   <label>OU1 Line: <input id="ou1Line" type="number" step="0.25" value="2.5"></label>
   <label>OU1 Over Open <input id="oddOver10" type="number" step="0.01"> Over Now <input id="oddOver11" type="number" step="0.01"><br>Under Open <input id="oddUnder10" type="number" step="0.01"> Under Now <input id="oddUnder11" type="number" step="0.01"></label>

   <label>OU2 Line: <input id="ou2Line" type="number" step="0.25" value="3.0"></label>
   <label>OU2 Over Open <input id="oddOver20" type="number" step="0.01"> Over Now <input id="oddOver21" type="number" step="0.01"><br>Under Open <input id="oddUnder20" type="number" step="0.01"> Under Now <input id="oddUnder21" type="number" step="0.01"></label>

   <div style="margin-top:8px">
    <button id="btnAnalyze">Analisis</button>
    <button id="btnContoh">Isi Contoh Otomatis</button>
    <button id="btnReset">Reset Input</button>
   </div>
  </div>
 </div>

 <div>
  <div class="block">
   <h3>Ringkasan Cepat</h3>
   <div id="summary" class="result">Klik Analisis untuk hasil.</div>
   <h3>Rekomendasi HDP & O/U</h3>
   <div id="rekom" class="result">--</div>
   <h3>Odds Trap (detail)</h3>
   <table id="trapTable"><tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Prob Model</th><th>Edge%</th><th>Sinyal</th></tr></table>
   <h3>Histogram Total Gol</h3>
   <canvas id="histChart" width="380" height="160" style="background:#0f0f0f;border-radius:6px;margin-top:10px"></canvas>
   <h3>Debug</h3>
   <div id="debug" class="result">--</div>
  </div>
 </div>
</div>

<script>
// --- utilities ---
function safe(v,d=0){const x=parseFloat(v);return isNaN(x)?d:x;}
function trimArr(s){if(!s) return [];return s.split(',').map(x=>x.trim().toUpperCase()).filter(Boolean);} 
function randNormal(mu=0,sigma=1){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return mu+sigma*Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);} 
function poissonRand(lambda){let L=Math.exp(-lambda),k=0,p=1;while(p>L){k++;p*=Math.random();if(k>1000)break;}return k-1;}
function sampleBivariateLognormal(lambdaH,lambdaA,rho,sigma){const z1=randNormal(0,sigma);const z2=rho*z1+Math.sqrt(Math.max(0,1-rho*rho))*randNormal(0,sigma);const lamH=Math.max(0.01,lambdaH*Math.exp(z1-0.5*sigma*sigma));const lamA=Math.max(0.01,lambdaA*Math.exp(z2-0.5*sigma*sigma));return [poissonRand(lamH),poissonRand(lamA)];}
function monteCarlo(lambdaH,lambdaA,rho,runs,sigma){const scoreFreq={},totals={};let h=0,d=0,a=0;for(let t=0;t<runs;t++){const [gh,ga]=sampleBivariateLognormal(lambdaH,lambdaA,rho,sigma);scoreFreq[`${gh}-${ga}`]=(scoreFreq[`${gh}-${ga}`]||0)+1;totals[gh+ga]=(totals[gh+ga]||0)+1;if(gh>ga)h++;else if(gh===ga)d++;else a++;}return{scoreFreq,totals,pHome:h/runs,pDraw:d/runs,pAway:a/runs};}
function computeOU(totals,line,runs){let over=0,under=0;const isInt=Number.isInteger(line);for(const k in totals){const g=parseInt(k),v=totals[k];if(isInt){if(g>line)over+=v;else if(g<line)under+=v;else{over+=0.5*v;under+=0.5*v;}}else{if(g>line)over+=v;else under+=v;}}return{over:over/runs,under:under/runs};}
function sf(eloT,eloO){return Math.max(0.7,Math.min(1.3,1+(eloT-eloO)/1200));}

// injury impact
const POS_WEIGHT = {GK:25, DF:15, MF:10, FW:20, OTHER:8};
function calcInjuryImpact(posList){const arr=trimArr(posList);let total=0;arr.forEach(p=>{total+=POS_WEIGHT[p]||POS_WEIGHT.OTHER;});const impactPercent=Math.min(60, total/2);return {count:arr.length,total,impactPercent,details:arr};}

// auto TI (tackles+inter)
function computeTotalTI(tackle, inter, injList){
 const base = safe(tackle,0) + safe(inter,0);
 const arr = trimArr(injList);
 const dfCount = arr.filter(x=>x==='DF').length;
 let adjusted = base;
 let note = '';
 if(dfCount>=2){ adjusted = adjusted * 0.85; note = `⚠️ ${dfCount} DF absen — total dikurangi 15%`; }
 return {base,adjusted,dfCount,note};
}

function updateTITotalsDisplay(){
 const h = computeTotalTI(safe(tackleHome.value), safe(interHome.value), injHome.value);
 const a = computeTotalTI(safe(tackleAway.value), safe(interAway.value), injAway.value);
 // color indicator
 const indHome = document.getElementById('totalHomeDisplay'); const indAway = document.getElementById('totalAwayDisplay');
 indHome.textContent = `Total: ${h.adjusted.toFixed(1)}`; indAway.textContent = `Total: ${a.adjusted.toFixed(1)}`;
 indHome.className = 'ind-small ' + (h.adjusted>=30? 'ind-strong' : (h.adjusted>=22? 'ind-mid' : 'ind-weak'));
 indAway.className = 'ind-small ' + (a.adjusted>=30? 'ind-strong' : (a.adjusted>=22? 'ind-mid' : 'ind-weak'));
 indHome.title = h.note; indAway.title = a.note;
 // store for analyze use
 indHome.dataset.value = h.adjusted; indAway.dataset.value = a.adjusted;
}

// attach listeners to auto-update when inputs change
['tackleHome','interHome','injHome','tackleAway','interAway','injAway'].forEach(id=>{const el=document.getElementById(id); if(el) el.addEventListener('input', updateTITotalsDisplay);});

// mini bar helper
function miniBarHtml(prob,type){const pct=Math.round(prob*100);const len=Math.round(pct/4);let cls='neutral';if(type==='over')cls='over';if(type==='under')cls='under';return `<span class="bar ${cls}" style="width:${Math.max(6,len*6)}px"></span> ${pct}%`;}

function probCoverFromScoreFreq(scoreFreq, runs, handicap){let win=0,push=0,loss=0;for(const sc in scoreFreq){const v=scoreFreq[sc];const [gh,ga] = sc.split('-').map(x=>parseInt(x));const adjusted = gh - ga - handicap; if(adjusted>0) win+=v; else if(Math.abs(adjusted) < 1e-9) push+=v; else loss+=v;}return {win:win/runs, push:push/runs, loss:loss/runs};}
function impliedProb(odds){return odds? 1/odds : null;}
function deltaPercent(open,now){if(!open||!now) return null; return ((now-open)/open*100).toFixed(1);} 

// main analyze
function analyze(){
 // update TI values first
 updateTITotalsDisplay();
 const totalTI_H = parseFloat(document.getElementById('totalHomeDisplay').dataset.value||0);
 const totalTI_A = parseFloat(document.getElementById('totalAwayDisplay').dataset.value||0);

 // read inputs
 const h={xg:safe(xgHome.value),sot:safe(sotHome.value),conv:safe(convHome.value),big:safe(bigHome.value),miss:safe(missHome.value),gc:safe(gcHome.value),save:safe(saveHome.value),tackleTotal:totalTI_H,poss:safe(possHome.value),err:safe(errHome.value),elo:safe(eloHome.value)};
 const a={xg:safe(xgAway.value),sot:safe(sotAway.value),conv:safe(convAway.value),big:safe(bigAway.value),miss:safe(missAway.value),gc:safe(gcAway.value),save:safe(saveAway.value),tackleTotal:totalTI_A,poss:safe(possAway.value),err:safe(errAway.value),elo:safe(eloAway.value)};
 const injH = calcInjuryImpact(injHome.value); const injA = calcInjuryImpact(injAway.value);

 // attack & defense indices
 const attH = 0.38*h.xg + 0.25*(h.sot*h.conv) + 0.15*h.big + 0.04*(h.poss/50);
 const attA = 0.38*a.xg + 0.25*(a.sot*a.conv) + 0.15*a.big + 0.04*(a.poss/50);
 let defH = 1 + (0.3*h.gc - 0.1*h.save - 0.08*(h.tackleTotal/25) + 0.1*h.err);
 let defA = 1 + (0.3*a.gc - 0.1*a.save - 0.08*(a.tackleTotal/25) + 0.1*a.err);

 // injury adjustments (keep previous logic)
 const injFactorH = 1 - (injH.impactPercent/100)*0.8; const injFactorA = 1 - (injA.impactPercent/100)*0.8;
 const defPenaltyH = 1 + (injH.impactPercent/100)*0.6; const defPenaltyA = 1 + (injA.impactPercent/100)*0.6;
 const attH_adj = Math.max(0.01, attH * injFactorH); const attA_adj = Math.max(0.01, attA * injFactorA);
 defH *= defPenaltyH; defA *= defPenaltyA;

 // special GK effect (reduce saves)
 function hasPos(list,pos){return trimArr(list).includes(pos);} 
 if(hasPos(injHome.value,'GK')){ h.save = Math.max(0, h.save * 0.85); }
 if(hasPos(injAway.value,'GK')){ a.save = Math.max(0, a.save * 0.85); }

 // lambdas
 const leagueAvg = (h.xg + a.xg)/2 || 1; const sfH = sf(h.elo,a.elo), sfA = sf(a.elo,h.elo);
 let lambdaH = leagueAvg * (attH_adj/leagueAvg) * (1/defA) * sfH;
 let lambdaA = leagueAvg * (attA_adj/leagueAvg) * (1/defH) * sfA;
 // conservative scaling
 const factor = 0.92; lambdaH *= factor; lambdaA *= factor;

 // Monte Carlo
 const runs = Math.max(1000, safe(mcRuns.value,3000)); const rho = safe(rho.value,0.12); const sigma = safe(dispersionSigma.value,0.30);
 const mc = monteCarlo(lambdaH, lambdaA, rho, runs, sigma);

 // totals / top scores
 const sorted = Object.entries(mc.scoreFreq).sort((a,b)=>b[1]-a[1]); const top = sorted.slice(0,6).map(([sc,v])=>`${sc} (${(100*v/runs).toFixed(1)}%)`).join(', ');
 const avgH = (Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s+parseInt(sc.split('-')[0])*v,0)/runs).toFixed(2);
 const avgA = (Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s+parseInt(sc.split('-')[1])*v,0)/runs).toFixed(2);

 // compute OU for both lines
 const ou1Line = safe(ou1Line.value,2.5); const ou2Line = safe(ou2Line.value,3.0);
 const ou1 = computeOU(mc.totals, ou1Line, runs); const ou2 = computeOU(mc.totals, ou2Line, runs);

 // Bayesian blend with market implied (for OU)
 const impliedOver1Now = impliedProb(safe(oddOver11.value,NaN)); const impliedUnder1Now = impliedProb(safe(oddUnder11.value,NaN));
 const impliedOver2Now = impliedProb(safe(oddOver21.value,NaN)); const impliedUnder2Now = impliedProb(safe(oddUnder21.value,NaN));
 const conf = Math.max(0.2, Math.min(0.9, 1 - (sigma/0.6)));
 const postOver1 = impliedOver1Now? (conf*ou1.over + (1-conf)*impliedOver1Now) : ou1.over;
 const postUnder1 = impliedUnder1Now? (conf*ou1.under + (1-conf)*impliedUnder1Now) : ou1.under;
 const postOver2 = impliedOver2Now? (conf*ou2.over + (1-conf)*impliedOver2Now) : ou2.over;
 const postUnder2 = impliedUnder2Now? (conf*ou2.under + (1-conf)*impliedUnder2Now) : ou2.under;

 // HDP markets evaluation
 const hdpMarkets = [
   {line: parseFloat(hdp1Line.value), homeOpen: safe(hdp1HomeOpen.value,NaN), homeNow: safe(hdp1HomeNow.value,NaN), awayOpen: safe(hdp1AwayOpen.value,NaN), awayNow: safe(hdp1AwayNow.value,NaN)},
   {line: parseFloat(hdp2Line.value), homeOpen: safe(hdp2HomeOpen.value,NaN), homeNow: safe(hdp2HomeNow.value,NaN), awayOpen: safe(hdp2AwayOpen.value,NaN), awayNow: safe(hdp2AwayNow.value,NaN)}
 ];

 const trapRows=[]; let rekom='';
 // add OU rows first
 trapRows.push(['OU1 '+ou1Line, safe(oddOver10.value,NaN), safe(oddOver11.value,NaN), deltaPercent(safe(oddOver10.value,NaN), safe(oddOver11.value,NaN)), (100*postOver1).toFixed(1)+'%', ((postOver1 - impliedOver1Now)?((postOver1-impliedOver1Now)*100).toFixed(2)+'%':''),'']);
 trapRows.push(['OU1 Under '+ou1Line, safe(oddUnder10.value,NaN), safe(oddUnder11.value,NaN), deltaPercent(safe(oddUnder10.value,NaN), safe(oddUnder11.value,NaN)), (100*postUnder1).toFixed(1)+'%', ((postUnder1 - impliedUnder1Now)?((postUnder1-impliedUnder1Now)*100).toFixed(2)+'%':''),'']);
 trapRows.push(['OU2 '+ou2Line, safe(oddOver20.value,NaN), safe(oddOver21.value,NaN), deltaPercent(safe(oddOver20.value,NaN), safe(oddOver21.value,NaN)), (100*postOver2).toFixed(1)+'%', ((postOver2 - impliedOver2Now)?((postOver2-impliedOver2Now)*100).toFixed(2)+'%':''),'']);
 trapRows.push(['OU2 Under '+ou2Line, safe(oddUnder20.value,NaN), safe(oddUnder21.value,NaN), deltaPercent(safe(oddUnder20.value,NaN), safe(oddUnder21.value,NaN)), (100*postUnder2).toFixed(1)+'%', ((postUnder2 - impliedUnder2Now)?((postUnder2-impliedUnder2Now)*100).toFixed(2)+'%':''),'']);

 // HDP rows and recommendation
 hdpMarkets.forEach((m,idx)=>{
   if(isNaN(m.line)) return;
   const cover = probCoverFromScoreFreq(mc.scoreFreq, runs, m.line);
   const coverProb = cover.win + 0.5*cover.push;
   const impliedHomeNow = impliedProb(m.homeNow); const impliedAwayNow = impliedProb(m.awayNow);
   const homeEdge = !isNaN(impliedHomeNow)? coverProb - impliedHomeNow : null;
   const awayCover = probCoverFromScoreFreq(mc.scoreFreq, runs, -m.line);
   const awayProb = awayCover.win + 0.5*awayCover.push;
   const awayEdge = !isNaN(impliedAwayNow)? awayProb - impliedAwayNow : null;
   const deltaH = deltaPercent(m.homeOpen, m.homeNow); const deltaA = deltaPercent(m.awayOpen, m.awayNow);
   // trap signals
   let sigH='Netral', sigA='Netral';
   if(deltaH!==null){ if(parseFloat(deltaH) < -5 && coverProb < (1/m.homeNow)) sigH='⚠️ Trap Turun'; else if(parseFloat(deltaH) < -5) sigH='Pasar berat Home'; }
   if(deltaA!==null){ if(parseFloat(deltaA) < -5 && awayProb < (1/m.awayNow)) sigA='⚠️ Trap Turun'; else if(parseFloat(deltaA) < -5) sigA='Pasar berat Away'; }
   trapRows.push([`HDP${idx+1} Home ${m.line}`, m.homeOpen, m.homeNow, deltaH, (100*coverProb).toFixed(1)+'%', homeEdge!==null?((homeEdge*100).toFixed(2)+'%'): '', sigH]);
   trapRows.push([`HDP${idx+1} Away ${-m.line}`, m.awayOpen, m.awayNow, deltaA, (100*awayProb).toFixed(1)+'%', awayEdge!==null?((awayEdge*100).toFixed(2)+'%'):'', sigA]);
   // recommendation logic: prefer markets with edge>=2% and prob>=58%
   if(homeEdge!==null && homeEdge>=0.02 && coverProb>=0.58 && sigH.indexOf('⚠️')<0) rekom += `✅ Ambil Home ${m.line} (HDP${idx+1}) Edge ${(homeEdge*100).toFixed(2)}%\n`;
   if(awayEdge!==null && awayEdge>=0.02 && awayProb>=0.58 && sigA.indexOf('⚠️')<0) rekom += `✅ Ambil Away ${-m.line} (HDP${idx+1}) Edge ${(awayEdge*100).toFixed(2)}%\n`;
 });

 // O/U recommendations (use posterior)
 function ouRecommend(postOver, postUnder, oddOverNow, oddUnderNow, line, which){
   let rec=''; let emoji='⚪'; let bar=''+miniBarHtml(0,'neutral');
   if(postOver>=0.60){ emoji='🔺'; bar=miniBarHtml(postOver,'over'); rec=`${emoji}${bar} → OVER ${line} (Prob ${(postOver*100).toFixed(1)}%)`; }
   else if(postUnder>=0.57){ emoji='🔻'; bar=miniBarHtml(postUnder,'under'); rec=`${emoji}${bar} → UNDER ${line} (Prob ${(postUnder*100).toFixed(1)}%)`; }
   else rec=`⚪ ${miniBarHtml(Math.max(postOver,postUnder),'neutral')} → Skip market ${line}`;
   const impliedO = impliedProb(oddOverNow), impliedU = impliedProb(oddUnderNow);
   const edgeO = impliedO? (postOver - impliedO) : null; const edgeU = impliedU? (postUnder - impliedU) : null;
   return {rec,edgeO,edgeU};
 }
 const ou1Rec = ouRecommend(postOver1, postUnder1, safe(oddOver11.value,NaN), safe(oddUnder11.value,NaN), ou1Line, 'OU1');
 const ou2Rec = ouRecommend(postOver2, postUnder2, safe(oddOver21.value,NaN), safe(oddUnder21.value,NaN), ou2Line, 'OU2');
 if(ou1Rec.rec && ou1Rec.rec.indexOf('OVER')> -1) rekom += `✅ ${ou1Rec.rec}\n`;
 if(ou1Rec.rec && ou1Rec.rec.indexOf('UNDER')> -1) rekom += `✅ ${ou1Rec.rec}\n`;
 if(ou2Rec.rec && ou2Rec.rec.indexOf('OVER')> -1) rekom += `✅ ${ou2Rec.rec}\n`;
 if(ou2Rec.rec && ou2Rec.rec.indexOf('UNDER')> -1) rekom += `✅ ${ou2Rec.rec}\n`;
 if(rekom==='') rekom='⚖️ Tidak ada rekomendasi kuat untuk HDP/O-U saat ini.';

 // build trap table
 let tableHtml = '<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Prob Model</th><th>Edge%</th><th>Sinyal</th></tr>';
 trapRows.forEach(r=>{tableHtml += '<tr>' + r.map(c=>`<td>${c===null?'':c}</td>`).join('') + '</tr>';});
 document.getElementById('trapTable').innerHTML = tableHtml;

 // summary + rekom
 document.getElementById('summary').textContent = `Top skor: ${top}\nλH=${lambdaH.toFixed(2)} | λA=${lambdaA.toFixed(2)}\nExpected G H:${avgH} A:${avgA}\nProb 1X2 H:${(100*mc.pHome).toFixed(1)}% D:${(100*mc.pDraw).toFixed(1)}% A:${(100*mc.pAway).toFixed(1)}%\n\nInjury Impact Home: ${injH.impactPercent}% (${injH.count} positions) | Away: ${injA.impactPercent}% (${injA.count} positions)\nTack+Inter Home: ${totalTI_H.toFixed(1)} | Away: ${totalTI_A.toFixed(1)}`;
 document.getElementById('rekom').textContent = rekom;

 // histogram draw
 const ctx = document.getElementById('histChart').getContext('2d'); ctx.clearRect(0,0,380,160);
 const totals = mc.totals; const labels = Object.keys(totals).map(x=>parseInt(x)).sort((a,b)=>a-b); const maxC = Math.max(...labels.map(k=>totals[k]||0),1); const w = Math.max(6,320/labels.length);
 labels.forEach((g,i)=>{const ht = (totals[g]/maxC)*120; ctx.fillStyle='#0b74de'; ctx.fillRect(10+i*w,140-ht,w-2,ht); ctx.fillStyle='#aaa'; ctx.font='10px Arial'; ctx.fillText(String(g), 10+i*w,150);});

 document.getElementById('debug').textContent = `MC runs:${runs} sigma:${sigma} rho:${rho} | injH:${injH.impactPercent}% injA:${injA.impactPercent}% | TI_H:${totalTI_H.toFixed(1)} TI_A:${totalTI_A.toFixed(1)}`;
}

// sample + reset
function isiContoh(){
 teamHome.value='Liverpool'; teamAway.value='Brentford';
 xgHome.value=1.9; xgAway.value=1.1; sotHome.value=5.2; sotAway.value=3.6;
 convHome.value=0.15; convAway.value=0.11; bigHome.value=2.2; missHome.value=0.8;
 bigAway.value=1.0; missAway.value=1.1; gcHome.value=1.0; gcAway.value=1.4;
 saveHome.value=3.4; saveAway.value=3.8; tackleHome.value=18.3; interHome.value=8.7; tackleAway.value=15.2; interAway.value=7.8;
 possHome.value=58; possAway.value=42; errHome.value=0.2; errAway.value=0.3;
 injHome.value='DF, DF'; injAway.value='FW'; eloHome.value=1580; eloAway.value=1470;
 mcRuns.value=4000; dispersionSigma.value=0.30; rho.value=0.12;
 hdp1Line.value='-0.5'; hdp1HomeOpen.value=1.95; hdp1HomeNow.value=1.88; hdp1AwayOpen.value=1.95; hdp1AwayNow.value=2.05;
 hdp2Line.value='-0.75'; hdp2HomeOpen.value=2.10; hdp2HomeNow.value=2.00; hdp2AwayOpen.value=1.82; hdp2AwayNow.value=1.90;
 ou1Line.value=2.5; oddOver10.value=1.95; oddOver11.value=1.88; oddUnder10.value=1.90; oddUnder11.value=2.00;
 ou2Line.value=3.0; oddOver20.value=2.10; oddOver21.value=2.00; oddUnder20.value=1.75; oddUnder21.value=1.85;
 updateTITotalsDisplay();
 alert('Contoh data telah diisi. Klik Analisis untuk melihat hasil.');
}
function resetInput(){document.querySelectorAll('input').forEach(i=>i.value=''); updateTITotalsDisplay(); alert('Semua input dikosongkan.');}

document.getElementById('btnContoh').onclick=isiContoh; document.getElementById('btnReset').onclick=resetInput; document.getElementById('btnAnalyze').onclick=analyze;
// init display
updateTITotalsDisplay();
</script>
</body>
</html>
