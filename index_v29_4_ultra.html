<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Prediksi Pertandingan - v29.4 Ultra Precision+</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;background:#0d0f10;color:#eef2f3}
  h1{font-size:20px}
  .grid{display:grid;grid-template-columns:1fr 480px;gap:14px}
  .block{padding:12px;border-radius:8px;border:1px solid #222;background:#141618}
  label{display:block;font-size:13px;margin:6px 0}
  input[type="number"],input[type="text"],select{width:100%;padding:7px;border:1px solid #333;border-radius:6px;background:#0f1315;color:#fff}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0b74de;color:#fff;cursor:pointer;margin:4px}
  .small{font-size:12px;color:#9aa3ad}
  .result{white-space:pre-wrap;font-family:monospace;background:#0b0d0f;padding:10px;border-radius:8px;border:1px dashed #222;margin-top:8px;color:#dfeefd}
  table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
  th,td{padding:6px;border-bottom:1px solid #1f2224;text-align:center}
  th{background:#0d0f11}
  .bar-wrap{height:10px;background:#111;border-radius:6px;overflow:hidden}
  .bar-fill{height:10px;border-radius:6px}
  .green{background:#1e8e3e}
  .yellow{background:#b79e20}
  .red{background:#d64545}
  .muted{color:#7f8b8e;font-size:12px}
  canvas{background:#070809;border-radius:6px}
</style>
</head>
<body>
<h1>⚽ Prediksi — v29.4 Ultra Precision+</h1>
<p class="small">Penambahan: absensi posisi (DF/MF/FW), weighted form, defense normalization, attack-defense interaction, confidence calibration.</p>

<div class="grid">
  <div>
    <div class="block">
      <h3>Input (Masukkan jumlah posisi absen — tanpa nama)</h3>
      <label>Home Team: <input id="teamHome" type="text" value="Home FC"></label>
      <label>Away Team: <input id="teamAway" type="text" value="Away FC"></label>
      <label>H2H (5 hasil, contoh WDLWL): <input id="h2hResults" type="text" maxlength="5"></label>

      <label>xG per Game: <input id="xgHome" type="number" step="0.01"> <input id="xgAway" type="number" step="0.01"></label>
      <label>Shots on Target: <input id="sotHome" type="number" step="0.1"> <input id="sotAway" type="number" step="0.1"></label>
      <label>Conversion Rate (0–1): <input id="convHome" type="number" step="0.01"> <input id="convAway" type="number" step="0.01"></label>

      <label>Tackles: <input id="tackleHome" type="number" step="0.1"> <input id="tackleAway" type="number" step="0.1"></label>
      <label>Interceptions: <input id="interHome" type="number" step="0.1"> <input id="interAway" type="number" step="0.1"></label>
      <label>Tackles + Interceptions (otomatis): <input id="tiHome" type="number" readonly> <input id="tiAway" type="number" readonly></label>

      <label>Clean Sheet / Game: <input id="csHome" type="number" step="0.01"> <input id="csAway" type="number" step="0.01"></label>
      <label>Goals Conceded / Game: <input id="gcHome" type="number" step="0.1"> <input id="gcAway" type="number" step="0.1"></label>
      <label>Saves / Game: <input id="saveHome" type="number" step="0.1"> <input id="saveAway" type="number" step="0.1"></label>
      <label>Errors leading to goal / season (est): <input id="errHome" type="number" step="0.1"> <input id="errAway" type="number" step="0.1"></label>

      <label>Performa 5 laga (pisahkan koma, contoh: W,D,W,L,D) — atau beri skor (0-1): <input id="formRawHome" type="text" placeholder="W,D,W,D,W"> <input id="formRawAway" type="text" placeholder="L,D,W,L,D"></label>
      <label>Atau langsung skor performa (0–1): <input id="formHome" type="number" step="0.01"> <input id="formAway" type="number" step="0.01"></label>

      <h4>Absensi posisi (jumlah)</h4>
      <label>Home — Defender <input id="absDfHome" type="number" step="1" min="0"> Midfielder <input id="absMfHome" type="number" step="1" min="0"> Forward <input id="absFwHome" type="number" step="1" min="0"></label>
      <label>Away — Defender <input id="absDfAway" type="number" step="1" min="0"> Midfielder <input id="absMfAway" type="number" step="1" min="0"> Forward <input id="absFwAway" type="number" step="1" min="0"></label>

      <label>ELO Rating: <input id="eloHome" type="number" value="1500"> <input id="eloAway" type="number" value="1480"></label>

      <h4>Odds (HDP + OU) — lines & odds</h4>
      <label>HDP Line <input id="hdpLine" type="number" step="0.25" value="0.25"></label>
      <label>HDP Home Open <input id="hdpHomeOpen" type="number" step="0.01"> Now <input id="hdpHomeNow" type="number" step="0.01"> | Away Open <input id="hdpAwayOpen" type="number" step="0.01"> Now <input id="hdpAwayNow" type="number" step="0.01"></label>

      <label>OU Line <input id="ouLine" type="number" step="0.25" value="2.5"></label>
      <label>OU Over Open <input id="ouOverOpen" type="number" step="0.01"> Over Now <input id="ouOverNow" type="number" step="0.01"> | Under Open <input id="ouUnderOpen" type="number" step="0.01"> Under Now <input id="ouUnderNow" type="number" step="0.01"></label>

      <label>Monte Carlo runs: <input id="mcRuns" type="number" value="6000" step="100"></label>
      <div style="margin-top:10px">
        <button id="btnExample">Isi Contoh</button>
        <button id="btnReset">Reset</button>
        <button id="btnAnalyze">Analisis Ultra</button>
      </div>
    </div>
  </div>

  <div>
    <div class="block">
      <h3>Ringkasan & Rekomendasi</h3>
      <div id="summary" class="result">Klik "Analisis Ultra".</div>

      <h3>Rekomendasi Terbaik (HDP & OU)</h3>
      <div id="bestRec" class="result">--</div>

      <h3>Odds Trap & Market Moves</h3>
      <table id="trapTable"><tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Prob Model</th><th>Edge%</th><th>Sinyal</th></tr></table>

      <h3>Histogram Total Gol</h3>
      <canvas id="hist" width="420" height="140"></canvas>

      <div id="debug" class="result small">--</div>
    </div>
  </div>
</div>

<script>
// Utilities
function safe(v,d=0){const x=parseFloat(v);return isNaN(x)?d:x;}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function randNormal(mu=0,sigma=1){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return mu+sigma*Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
function poisson(k){let L=Math.exp(-k),p=1,c=0;while(p>L){c++;p*=Math.random();if(c>1000)break;}return c-1;}

// Auto TI
function autoTI(){
  tiHome.value = (safe(tackleHome.value)+safe(interHome.value)).toFixed(1);
  tiAway.value = (safe(tackleAway.value)+safe(interAway.value)).toFixed(1);
}
['tackleHome','interHome','tackleAway','interAway'].forEach(id=>document.getElementById(id).addEventListener('input',autoTI));

// Parse form raw like W,D,W,L,D -> weighted score
function formScoreFromRaw(raw){
  if(!raw) return null;
  const parts = raw.toString().split(',').map(s=>s.trim().toUpperCase()).filter(Boolean).slice(0,5);
  if(parts.length===0) return null;
  const weights = [0.35,0.25,0.20,0.12,0.08]; // more weight to recent matches (left=recent)
  let score=0, totalW=0;
  for(let i=0;i<parts.length;i++){
    const p = parts[i]; let val=0; if(p==='W') val=1; else if(p==='D') val=0.5; else val=0;
    score += val * weights[i]; totalW += weights[i];
  }
  return score / totalW; // normalized 0..1
}

// Attack & defense with absentee impact & normalization
function computeAttack(h){
  // base attack index from features
  const base = 0.33*h.xg + 0.20*(h.sot/5) + 0.12*(h.conv*100) + 0.08*(h.form||0.5);
  // absentee penalties: forward and MF missing reduce attack
  const lossFromFw = 0.07 * (h.absFw||0);
  const lossFromMf = 0.05 * (h.absMf||0);
  return Math.max(0.2, base - lossFromFw - lossFromMf);
}

function computeDefense(h){
  const ti = safe(h.ti,18);
  const errPerGame = safe(h.err,7) / 38.0;
  // base defense (lower is better); more ga increases value (worse)
  let val = 1 + (-0.26*h.cs + 0.30*h.gc - 0.10*(h.saves/4) - 0.095*(ti/25) + 0.12*errPerGame);
  // defender absences increase defensive weakness
  const extraDf = 0.08 * (h.absDf||0);
  val += extraDf;
  // midfielders missing slightly increase defensive fragility
  val += 0.03 * (h.absMf||0);
  return clamp(val,0.5,2.5);
}

// Weighted combination for lambda and interaction term
function computeLambdas(h,a){
  // compute attack & defense
  const atkH = computeAttack(h), atkA = computeAttack(a);
  const defH = computeDefense(h), defA = computeDefense(a);
  // ELO scaling
  const sfH = clamp(1 + (h.elo - a.elo)/1400, 0.75, 1.25);
  const sfA = clamp(1 + (a.elo - h.elo)/1400, 0.75, 1.25);
  const leagueAvg = Math.max(0.7, (h.xg + a.xg)/2);
  // base lambdas
  let lambdaH = leagueAvg * (atkH / Math.max(0.35, leagueAvg)) * (1/defA) * sfH;
  let lambdaA = leagueAvg * (atkA / Math.max(0.35, leagueAvg)) * (1/defH) * sfA;
  // interaction shrink: if both lambdas high, dampen both to avoid extreme over bias to Over
  const avgLam = (lambdaH + lambdaA)/2;
  if(avgLam > 3.0){
    lambdaH *= 0.85; lambdaA *= 0.85;
  } else if(avgLam > 2.0){
    lambdaH *= 0.92; lambdaA *= 0.92;
  }
  // small H2H influence handled outside
  // Bayesian shrinkage toward raw xG
  const shrinkW = 0.55;
  lambdaH = shrinkW*lambdaH + (1-shrinkW)*h.xg;
  lambdaA = shrinkW*lambdaA + (1-shrinkW)*a.xg;
  // calibrate
  lambdaH *= 0.98; lambdaA *= 0.98;
  return {lambdaH, lambdaA, atkH, atkA, defH, defA};
}

// Sampling and MC (lognormal noise)
function sampleBivar(lambdaH,lambdaA,rho,sigma){
  const z1 = randNormal(0,sigma);
  const z2 = rho*z1 + Math.sqrt(Math.max(0,1-rho*rho))*randNormal(0,sigma);
  const lamH = Math.max(0.01, lambdaH * Math.exp(z1 - 0.5*sigma*sigma));
  const lamA = Math.max(0.01, lambdaA * Math.exp(z2 - 0.5*sigma*sigma));
  return [poisson(lamH), poisson(lamA)];
}

function monteCarlo(lambdaH,lambdaA,rho,sigma,runs){
  const scoreFreq={}, totals={}; let h=0,d=0,a=0;
  for(let i=0;i<runs;i++){
    const [gh,ga] = sampleBivar(lambdaH,lambdaA,rho,sigma);
    const key = `${gh}-${ga}`;
    scoreFreq[key] = (scoreFreq[key]||0)+1;
    totals[gh+ga] = (totals[gh+ga]||0)+1;
    if(gh>ga) h++; else if(gh===ga) d++; else a++;
  }
  return {scoreFreq, totals, pHome:h/runs, pDraw:d/runs, pAway:a/runs};
}

// Prob cover HDP and OU from MC results
function probCoverFromScores(scoreFreq,handicap,runs){
  let win=0,push=0,lose=0;
  for(const sc in scoreFreq){
    const v=scoreFreq[sc]; const [gh,ga]=sc.split('-').map(x=>parseInt(x));
    const diff = gh - ga - handicap;
    if(diff>0) win+=v; else if(diff===0) push+=v; else lose+=v;
  }
  return (win + 0.5*push)/runs;
}
function probOUFromTotals(totals,line,runs){
  let over=0,under=0; const isInt = Number.isInteger(line);
  for(const t in totals){
    const g=parseInt(t), v=totals[t];
    if(isInt){ if(g>line) over+=v; else if(g<line) under+=v; else { over+=0.5*v; under+=0.5*v; } }
    else { if(g>line) over+=v; else under+=v; }
  }
  return {over: over/runs, under: under/runs};
}

// Implied prob and edge
function impliedProb(odds){ if(!odds||odds<=0) return null; return 1/odds; }
function shrinkEdge(e){ if(e===null) return null; const cap=0.20; return Math.sign(e)*Math.min(Math.abs(e),cap); }

// Confidence calibration based on variance of totals and model entropy
function computeConfidence(totals){
  // compute variance of total goals distribution
  let mean=0, varv=0, count=0;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; mean += g*v; count += v; }
  if(count===0) return {score:0.5,label:'Low'};
  mean /= count;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; varv += ((g-mean)**2)*v; }
  varv /= count;
  // lower variance -> higher confidence. scale inversely
  const conf = clamp(1 - Math.min(1, varv/9), 0.2, 0.95); // heuristic
  const label = conf>0.75? 'High' : (conf>0.5? 'Medium' : 'Low');
  return {score:conf,label};
}

// UI helpers
function percent(x){return (100*x).toFixed(1)+'%';}
function barHtml(p){ const pct = Math.round(p*100); const color = p>=0.58?'#1e8e3e':(p>=0.52?'#b79e20':'#555'); return `<div class="bar-wrap"><div class="bar-fill" style="width:${pct}%;background:${color}"></div></div> ${pct}%`; }

// Main analyze
function analyzeUltra(){
  const runs = Math.max(1000, safe(mcRuns.value,6000));
  const rho = 0.12, sigma = 0.30;

  // read inputs and prepare structures
  function readTeam(prefix){
    return {
      xg: safe(document.getElementById(prefix+'xg').value,1.0),
      sot: safe(document.getElementById(prefix+'sot').value,3.4),
      conv: clamp(safe(document.getElementById(prefix+'conv').value,0.12),0,1),
      tackle: safe(document.getElementById(prefix+'tackle').value,18),
      inter: safe(document.getElementById(prefix+'inter').value,7),
      ti: safe(document.getElementById(prefix+'ti').value,25),
      cs: safe(document.getElementById(prefix+'cs').value,0.32),
      gc: safe(document.getElementById(prefix+'gc').value,1.2),
      saves: safe(document.getElementById(prefix+'save').value,3.6),
      err: safe(document.getElementById(prefix+'err').value,7),
      formRaw: document.getElementById(prefix+'formRaw'+(prefix===''? '': '')), // placeholder
      form: safe(document.getElementById(prefix+'form').value, NaN),
      absDf: safe(document.getElementById(prefix+'absDf'+(prefix===''? '': '')).value,0),
      absMf: safe(document.getElementById(prefix+'absMf'+(prefix===''? '': '')).value,0),
      absFw: safe(document.getElementById(prefix+'absFw'+(prefix===''? '': '')).value,0),
      elo: safe(document.getElementById(prefix+'elo').value,1500)
    };
  }
  // but we use explicit ids: easier read
  const h = {
    xg: safe(xgHome.value,1.1), sot: safe(sotHome.value,3.4), conv: clamp(safe(convHome.value,0.12),0,1),
    tackle: safe(tackleHome.value,18), inter: safe(interHome.value,7), ti: safe(tiHome.value,25),
    cs: safe(csHome.value,0.32), gc: safe(gcHome.value,1.2), saves: safe(saveHome.value,3.6),
    err: safe(errHome.value,7), formRaw: (formRawHome.value||''), form: Number.isFinite(parseFloat(formHome.value))? safe(formHome.value): null,
    absDf: safe(absDfHome.value,0), absMf: safe(absMfHome.value,0), absFw: safe(absFwHome.value,0),
    elo: safe(eloHome.value,1500)
  };
  const a = {
    xg: safe(xgAway.value,1.0), sot: safe(sotAway.value,3.0), conv: clamp(safe(convAway.value,0.11),0,1),
    tackle: safe(tackleAway.value,16), inter: safe(interAway.value,6), ti: safe(tiAway.value,20),
    cs: safe(csAway.value,0.28), gc: safe(gcAway.value,1.3), saves: safe(saveAway.value,3.7),
    err: safe(errAway.value,8), formRaw: (formRawAway.value||''), form: Number.isFinite(parseFloat(formAway.value))? safe(formAway.value): null,
    absDf: safe(absDfAway.value,0), absMf: safe(absMfAway.value,0), absFw: safe(absFwAway.value,0),
    elo: safe(eloAway.value,1480)
  };

  // derive form score: prefer raw form input; else parse text; else default 0.5
  function deriveForm(team){
    if(Number.isFinite(team.form) && team.form>0) return clamp(team.form,0,1);
    const parsed = formScoreFromRaw(team.formRaw);
    if(parsed!==null) return clamp(parsed,0,1);
    return 0.5;
  }
  h.form = deriveForm(h); a.form = deriveForm(a);

  // populate ti from tackles+interceptions if not set
  if(!Number.isFinite(h.ti) || h.ti===0) h.ti = safe(tackleHome.value,0) + safe(interHome.value,0);
  if(!Number.isFinite(a.ti) || a.ti===0) a.ti = safe(tackleAway.value,0) + safe(interAway.value,0);

  // add absences into team objects
  h.absDf = safe(absDfHome.value,0); h.absMf = safe(absMfHome.value,0); h.absFw = safe(absFwHome.value,0);
  a.absDf = safe(absDfAway.value,0); a.absMf = safe(absMfAway.value,0); a.absFw = safe(absFwAway.value,0);

  // compute lambdas
  const res = computeLambdas(h,a);
  let lambdaH = res.lambdaH, lambdaA = res.lambdaA;
  const atkH = res.atkH, atkA = res.atkA, defH = res.defH, defA = res.defA;

  // H2H influence
  const h2hRaw = (function(s){ if(!s) return null; const t=s.toUpperCase().replace(/[^WDL]/g,'').slice(0,5); if(!t) return null; let w=(t.match(/W/g)||[]).length; let l=(t.match(/L/g)||[]).length; return (w - l)/Math.max(1,t.length); })(h2hResults.value);
  if(h2hRaw!==null){ lambdaH *= (1 + 0.06*h2hRaw); lambdaA *= (1 - 0.06*h2hRaw); }

  // Monte Carlo
  const mc = monteCarlo(lambdaH,lambdaA,0.12,0.30,runs);

  // aggregates
  const avgH = Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[0])*v,0)/runs;
  const avgA = Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[1])*v,0)/runs;

  // OU & HDP probabilities
  const ouLine = safe(ouLine.value,2.5);
  const ouProb = probOUFromTotals(mc.totals,ouLine,runs);
  const hdpLine = safe(hdpLine.value,0.25);
  const coverHome = probCoverFromScores(mc.scoreFreq, hdpLine, runs);
  const coverAway = probCoverFromScores(mc.scoreFreq, -hdpLine, runs);

  // implied market
  const implied = {
    ouOver: impliedProb(safe(ouOverNow.value,NaN)), ouUnder: impliedProb(safe(ouUnderNow.value,NaN)),
    hdpHome: impliedProb(safe(hdpHomeNow.value,NaN)), hdpAway: impliedProb(safe(hdpAwayNow.value,NaN)),
    ouOverOpen: impliedProb(safe(ouOverOpen.value,NaN)), ouUnderOpen: impliedProb(safe(ouUnderOpen.value,NaN)),
    hdpHomeOpen: impliedProb(safe(hdpHomeOpen.value,NaN)), hdpAwayOpen: impliedProb(safe(hdpAwayOpen.value,NaN))
  };

  // compute edges
  const edges = {
    ouOver: (implied.ouOver? (ouProb.over - implied.ouOver) : null),
    ouUnder: (implied.ouUnder? (ouProb.under - implied.ouUnder) : null),
    hdpHome: (implied.hdpHome? (coverHome - implied.hdpHome) : null),
    hdpAway: (implied.hdpAway? (coverAway - implied.hdpAway) : null)
  };

  // confidence
  const conf = computeConfidence(mc.totals);

  // build summary
  let summary = `λ (model): Home ${lambdaH.toFixed(2)} | Away ${lambdaA.toFixed(2)}\n`;
  summary += `Attack idx H:${atkH.toFixed(2)} A:${atkA.toFixed(2)} | Defense idx H:${defH.toFixed(2)} A:${defA.toFixed(2)}\n`;
  summary += `Exp Goals (sim): H ${avgH.toFixed(2)} | A ${avgA.toFixed(2)}\n`;
  summary += `Prob 1X2 — Home ${(100*mc.pHome).toFixed(1)}% Draw ${(100*mc.pDraw).toFixed(1)}% Away ${(100*mc.pAway).toFixed(1)}%\n`;
  summary += `OU (Line ${ouLine}) → Over ${percent(ouProb.over)} | Under ${percent(ouProb.under)}\n`;
  summary += `HDP (Line ${hdpLine}) → Home ${percent(coverHome)} | Away ${percent(coverAway)}\n`;
  summary += `Confidence: ${conf.label} (${(100*conf.score).toFixed(1)}%)\n`;

  document.getElementById('summary').textContent = summary;

  // recommendations - threshold + edge shrink
  const recs = [];
  function consider(tag,prob,edge,desc){
    const e = edge===null?null:shrinkEdge(edge);
    if(e!==null && prob>=0.58 && e>=0.02) recs.push({tag,prob,e,desc,signal:'strong'});
    else if(e!==null && prob>=0.55 && e>=0.015) recs.push({tag,prob,e,desc,signal:'medium'});
    else if(prob>=0.62 && e===null) recs.push({tag,prob,e,desc,signal:'model-only'});
  }
  consider(`OU Over ${ouLine}`, ouProb.over, edges.ouOver, `Over ${ouLine}`);
  consider(`OU Under ${ouLine}`, ouProb.under, edges.ouUnder, `Under ${ouLine}`);
  consider(`HDP Home ${hdpLine}`, coverHome, edges.hdpHome, `Home covers ${hdpLine}`);
  consider(`HDP Away ${-hdpLine}`, coverAway, edges.hdpAway, `Away covers ${-hdpLine}`);

  // sort by edge*prob
  recs.sort((a,b)=> (b.e||0)*(b.prob||0) - (a.e||0)*(a.prob||0));

  // render recommendations
  const bestDiv = document.getElementById('bestRec');
  if(recs.length===0){
    bestDiv.innerHTML = `<div class="muted">Tidak ada rekomendasi kuat. Confidence: ${conf.label} (${(100*conf.score).toFixed(1)}%)</div>`;
  } else {
    let html='';
    recs.forEach(r=>{
      html += `<div style="padding:8px;border-radius:6px;background:#0b1012;margin-bottom:6px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>${r.tag}</strong><div class="muted">${r.desc}</div></div>
          <div style="text-align:right"><div style="font-size:14px">${percent(r.prob)}</div><div style="font-size:12px">${r.e!==null? ((r.e*100).toFixed(2)+'% edge') : 'No market odds'}</div></div>
        </div>
        <div style="margin-top:6px">${barHtml(r.prob)}</div>
      </div>`;
    });
    bestDiv.innerHTML = html;
  }

  // trap table build
  const trapRows = [
    ['OU '+ouLine, safe(ouOverOpen.value,NaN), safe(ouOverNow.value,NaN), null, percent(ouProb.over), edges.ouOver!==null?((edges.ouOver*100).toFixed(2)+'%'):'-', (edges.ouOver!==null && edges.ouOver>=0.02)?'Value':'-'],
    ['HDP '+hdpLine, safe(hdpHomeOpen.value,NaN), safe(hdpHomeNow.value,NaN), null, percent(coverHome), edges.hdpHome!==null?((edges.hdpHome*100).toFixed(2)+'%'):'-', (edges.hdpHome!==null && edges.hdpHome>=0.02)?'Value':'-']
  ];
  let table = '<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Prob Model</th><th>Edge%</th><th>Sinyal</th></tr>';
  trapRows.forEach(r=> table += '<tr>' + r.map(c=>`<td>${c===null?'':c}</td>`).join('') + '</tr>');
  document.getElementById('trapTable').innerHTML = table;

  // histogram
  const ctx = document.getElementById('hist').getContext('2d'); ctx.clearRect(0,0,420,140);
  const keys = Object.keys(mc.totals).map(x=>parseInt(x)).sort((a,b)=>a-b);
  const maxV = Math.max(...keys.map(k=>mc.totals[k]||0),1);
  const w = Math.max(20, 380/Math.max(1,keys.length));
  keys.forEach((k,i)=>{
    const hgt = (mc.totals[k]/maxV)*110;
    ctx.fillStyle = '#0b74de';
    ctx.fillRect(10 + i*w, 120 - hgt, w-8, hgt);
    ctx.fillStyle='#9fb3c5'; ctx.font='10px Arial'; ctx.fillText(String(k), 10 + i*w, 136);
  });

  document.getElementById('debug').textContent = `lambdaH:${lambdaH.toFixed(2)} lambdaA:${lambdaA.toFixed(2)} atkH:${atkH.toFixed(2)} defA:${defA.toFixed(2)} confidence:${(100*conf.score).toFixed(1)}%`;
}

// example & reset handlers
function fillExample(){
  teamHome.value='Man City'; teamAway.value='Tottenham';
  h2hResults.value='WDWLW';
  xgHome.value=2.1; xgAway.value=1.4; sotHome.value=6.2; sotAway.value=4.1; convHome.value=0.16; convAway.value=0.12;
  tackleHome.value=22; interHome.value=9; tackleAway.value=17; interAway.value=7; autoTI();
  csHome.value=0.48; csAway.value=0.30; gcHome.value=0.8; gcAway.value=1.3; saveHome.value=3.6; saveAway.value=3.2;
  errHome.value=5; errAway.value=9; formRawHome.value='W,W,D,W,L'; formRawAway.value='L,D,W,L,D'; formHome.value=''; formAway.value='';
  absDfHome.value=1; absMfHome.value=0; absFwHome.value=1; absDfAway.value=0; absMfAway.value=2; absFwAway.value=0;
  eloHome.value=1820; eloAway.value=1690;
  hdpLine.value=0.25; hdpHomeOpen.value=1.95; hdpHomeNow.value=1.88; hdpAwayOpen.value=1.95; hdpAwayNow.value=2.05;
  ouLine.value=2.5; ouOverOpen.value=1.95; ouOverNow.value=1.88; ouUnderOpen.value=1.90; ouUnderNow.value=2.00;
  mcRuns.value=6000;
  alert('Contoh terisi. Klik Analisis Ultra.');
}
function resetAll(){
  document.querySelectorAll('input').forEach(i=>{ if(i.type!=='button') i.value=''; });
  document.getElementById('summary').textContent='Direset.'; document.getElementById('bestRec').textContent='--';
  document.getElementById('trapTable').innerHTML='<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Prob Model</th><th>Edge%</th><th>Sinyal</th></tr>';
  const ctx=document.getElementById('hist').getContext('2d'); ctx.clearRect(0,0,420,140);
}

document.getElementById('btnAnalyze').addEventListener('click',analyzeUltra);
document.getElementById('btnExample').addEventListener('click',fillExample);
document.getElementById('btnReset').addEventListener('click',resetAll);

</script>
</body>
</html>