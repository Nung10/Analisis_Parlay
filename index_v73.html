<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prediksi Odds & Lines — v73 Full (Readable)</title>
<style>
:root{--bg:#041018;--panel:#071826;--muted:#9fb3c5;--accent:#0b74de;--good:#2ecc71;--warn:#f1c40f;--bad:#e74c3c;--text:#dff3ff}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
.container{max-width:980px;margin:18px auto;padding:18px}
h1{margin:0 0 8px;font-size:22px;color:#cfe9ff}
.panel{background:var(--panel);border-radius:10px;padding:12px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.03)}
label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
input[type="text"], input[type="number"], input[type="date"], select, textarea {width:100%;padding:8px;border-radius:8px;border:1px solid #22333f;background:#08131a;color:#fff;font-size:14px}
.row{display:flex;gap:10px;flex-wrap:wrap}
.col{flex:1 1 260px;min-width:220px}
button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
button.ghost{background:transparent;border:1px solid #233645;color:#cfe9ff;padding:6px 8px;border-radius:6px;cursor:pointer}
.small{font-size:12px;color:var(--muted)}
.result{background:#06121a;padding:12px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);font-family:monospace;white-space:pre-wrap}
.progress-wrap{background:#07202a;border-radius:10px;padding:6px;margin-top:8px}
.progress-fill{height:16px;border-radius:8px;width:0%;transition:width .6s ease}
.table{width:100%;border-collapse:collapse;margin-top:8px}
.table th,.table td{padding:6px;border-bottom:1px solid #0f2a33;text-align:left;font-size:13px}
canvas{background:transparent;border-radius:6px}
@media (max-width:720px){.col{flex-basis:100%}}
</style>
</head>
<body>
<div class="container">
  <h1>Prediksi Odds & Lines — v73 Full (Readable)</h1>
  <p class="small">Versi ini mempertahankan semua fitur, tanpa mengembalikan contoh otomatis. Perhitungan telah dipertajam dan dinetralisasi.</p>

  <!-- Inputs -->
  <div class="panel">
    <h3>Informasi Pertandingan</h3>
    <div class="row">
      <div class="col"><label>League / Cup</label><select id="competition"><option>League</option><option>Cup</option><option>Friendly</option></select></div>
      <div class="col"><label>Tanggal</label><input id="matchDate" type="date"></div>
    </div>
    <label>Nama Pertandingan (Home vs Away)</label>
    <input id="matchName" type="text" placeholder="Contoh: Atalanta vs Lazio">
  </div>

  <div class="panel">
    <h3>Data Tim & Statistik</h3>
    <div class="row">
      <div class="col">
        <label>Home Team</label><input id="teamHome" type="text" placeholder="Home FC">
        <label>Average Rating (Sofascore) - Home</label><input id="ratingHome" type="number" step="0.01" placeholder="6.8">
        <label>Form Home (0-1)</label><input id="formHome" type="number" step="0.01" placeholder="0.68">
        <label>xG per game (Home)</label><input id="xgHome" type="number" step="0.01" placeholder="1.3">
        <label>Shots on Target per game (Home)</label><input id="sotHome" type="number" step="0.1" placeholder="4.5">
      </div>

      <div class="col">
        <label>Away Team</label><input id="teamAway" type="text" placeholder="Away FC">
        <label>Average Rating (Sofascore) - Away</label><input id="ratingAway" type="number" step="0.01" placeholder="6.7">
        <label>Form Away (0-1)</label><input id="formAway" type="number" step="0.01" placeholder="0.62">
        <label>xG per game (Away)</label><input id="xgAway" type="number" step="0.01" placeholder="1.1">
        <label>Shots on Target per game (Away)</label><input id="sotAway" type="number" step="0.1" placeholder="3.6">
      </div>
    </div>

    <h4 style="margin-top:10px">Clean Sheet & Goals Against</h4>
    <div class="row">
      <div class="col">
        <label>Clean Sheets (Home) — jumlah</label><input id="csCountHome" type="number" step="1" placeholder="5">
        <label>Matches considered (Home)</label><input id="csMatchesHome" type="number" step="1" placeholder="12">
        <label>Clean Sheet Ratio (Home)</label><input id="csHome" type="number" step="0.01" placeholder="0.42">
      </div>
      <div class="col">
        <label>Clean Sheets (Away) — jumlah</label><input id="csCountAway" type="number" step="1" placeholder="4">
        <label>Matches considered (Away)</label><input id="csMatchesAway" type="number" step="1" placeholder="12">
        <label>Clean Sheet Ratio (Away)</label><input id="csAway" type="number" step="0.01" placeholder="0.33">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div class="col">
        <label>Total Goals Conceded (Home)</label><input id="gcHomeCount" type="number" step="1" placeholder="13">
        <label>Matches considered (Home) for GA</label><input id="gcMatchesHome" type="number" step="1" placeholder="12">
        <label>Goals Conceded per Match (Home)</label><input id="gcHome" type="number" step="0.01" placeholder="1.08">
      </div>
      <div class="col">
        <label>Total Goals Conceded (Away)</label><input id="gcAwayCount" type="number" step="1" placeholder="15">
        <label>Matches considered (Away) for GA</label><input id="gcMatchesAway" type="number" step="1" placeholder="12">
        <label>Goals Conceded per Match (Away)</label><input id="gcAway" type="number" step="0.01" placeholder="1.25"></div>
    </div>

    <h4 style="margin-top:10px">Pemain Inti Cedera (posisi)</h4>
    <div class="row">
      <div class="col">
        <label>Home - Posisi Cedera</label>
        <table class="table">
          <tr><th>Posisi</th><th>Cedera?</th><th>Impact (%)</th></tr>
          <tr><td>GK</td><td><input id="injHomeGK" type="checkbox"></td><td><input id="impHomeGK" type="number" step="1" value="5"></td></tr>
          <tr><td>DF</td><td><input id="injHomeDF" type="checkbox"></td><td><input id="impHomeDF" type="number" step="1" value="5"></td></tr>
          <tr><td>MF</td><td><input id="injHomeMF" type="checkbox"></td><td><input id="impHomeMF" type="number" step="1" value="5"></td></tr>
          <tr><td>FW</td><td><input id="injHomeFW" type="checkbox"></td><td><input id="impHomeFW" type="number" step="1" value="5"></td></tr>
        </table>
      </div>

      <div class="col">
        <label>Away - Posisi Cedera</label>
        <table class="table">
          <tr><th>Posisi</th><th>Cedera?</th><th>Impact (%)</th></tr>
          <tr><td>GK</td><td><input id="injAwayGK" type="checkbox"></td><td><input id="impAwayGK" type="number" step="1" value="5"></td></tr>
          <tr><td>DF</td><td><input id="injAwayDF" type="checkbox"></td><td><input id="impAwayDF" type="number" step="1" value="5"></td></tr>
          <tr><td>MF</td><td><input id="injAwayMF" type="checkbox"></td><td><input id="impAwayMF" type="number" step="1" value="5"></td></tr>
          <tr><td>FW</td><td><input id="injAwayFW" type="checkbox"></td><td><input id="impAwayFW" type="number" step="1" value="5"></td></tr>
        </table>
      </div>
    </div>
  </div>

  <!-- Odds & Controls -->
  <div class="panel">
    <h3>Odds & Simulation</h3>
    <div class="row">
      <div class="col"><label>HDP Line</label><input id="hdpLine" type="number" step="0.25" value="0.25"></div>
      <div class="col"><label>OU Line</label><input id="ouLine" type="number" step="0.25" value="2.5"></div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col"><label>HDP Home (Now)</label><input id="hdpHomeNow" type="number" step="0.01"></div>
      <div class="col"><label>HDP Away (Now)</label><input id="hdpAwayNow" type="number" step="0.01"></div>
      <div class="col"><label>OU Over (Now)</label><input id="ouOverNow" type="number" step="0.01"></div>
    </div>
    <div class="row" style="margin-top:8px">
      <div class="col"><label>OU Under (Now)</label><input id="ouUnderNow" type="number" step="0.01"></div>
      <div class="col"><label>ρ (rho)</label><input id="rho" type="number" step="0.01" value="0.12"></div>
      <div class="col"><label>Alpha (shrink)</label><input id="alpha" type="number" step="0.01" value="0.15"></div>
    </div>

    <div style="margin-top:10px">
      <button id="btnAnalyze">Analisis</button>
      <button id="btnReset" class="ghost">Reset</button>
      <button id="btnDownload" class="ghost">Download CSV</button>
    </div>
  </div>

  <!-- Results -->
  <div class="panel">
    <h3>Hasil & Rekomendasi</h3>
    <div id="summary" class="result" style="margin-top:8px">Klik Analisis untuk hasil.</div>

    <div id="recs" style="margin-top:8px"></div>

    <div style="margin-top:12px">
      <label class="small">Confidence Meter</label>
      <div class="progress-wrap"><div id="confFill" class="progress-fill" style="background:#00ff9d;width:0%"></div></div>
      <div id="confText" class="small" style="text-align:right;margin-top:6px">Confidence: 0%</div>
    </div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:center;flex-wrap:wrap">
      <canvas id="hist" width="520" height="140"></canvas>
    </div>

    <div id="debug" class="result" style="margin-top:8px;background:#07121b"></div>
  </div>

  <p class="small muted">Catatan: jangan isi contoh otomatis — semua data harus berasal dari input Anda.</p>
</div>

<script>
/* ----------------- Utilities ----------------- */
function safe(v,d=NaN){ const x=parseFloat(v); return isNaN(x)?d:x; }
function pct(x){ if(isNaN(x)) return '-'; return (100*x).toFixed(1)+'%'; }
function clamp(v,a,b){ if(v<a) return a; if(v>b) return b; return v; }

// Poisson sampling (simple, bounded)
function poisson(lambda){
  const L = Math.exp(-lambda);
  let p = 1.0; let k = 0;
  while (p > L) {
    k++; p *= Math.random();
    if (k > 10000) break;
  }
  return k - 1;
}

/* ----------------- Core indices ----------------- */
function computeAttackIndex(xg, sot, form, rating) {
  // fallbacks
  const xg_v = (typeof xg === 'number' && xg>0)? xg : 0.9;
  const sot_v = (typeof sot === 'number' && sot>0)? sot : 3.5;
  const form_v = clamp((typeof form === 'number' ? form : 0.5), 0, 1);
  const rating_v = (typeof rating === 'number' && rating>0)? rating : 6.4;

  // normalize xG to smooth 0..1
  const xg_norm = Math.tanh((xg_v - 1.05)/1.0) * 0.5 + 0.5;
  // expected SOT from xG (reduce SOT weight if xG small)
  const sot_expected = Math.max(1.5, 3.6 * (xg_v / 1.1));
  const sot_rel = clamp(sot_v / (sot_expected + 1e-6), 0.2, 2.5);
  const sot_norm = Math.tanh((sot_rel - 1)/1.2) * 0.4 + 0.5;

  const rating_mult = clamp((rating_v - 5.5)/2.0, -0.4, 0.6) + 1; // ~0.6..1.6
  const form_mult = 0.8 + 0.4 * form_v; // 0.8..1.2

  const base = 0.55 * xg_norm + 0.25 * sot_norm + 0.20 * (0.5 * form_v + 0.5);
  const attack_score = Math.max(0.06, base * rating_mult * form_mult);

  // map to lambda goals per match
  const lambda = clamp(0.3 + attack_score * 2.0, 0.08, 3.0);
  return lambda;
}

function computeDefenseIndex(cs, ga) {
  const cs_v = clamp((typeof cs === 'number' ? cs : 0.25), 0, 1);
  const ga_v = (typeof ga === 'number' && ga>0)? ga : 1.25;

  // clean sheet reduces vulnerability; GA increases it
  const cs_effect = 1 - (0.65 * Math.pow(cs_v, 0.7)); // cs 1 -> 0.35
  const ga_effect = 1 + Math.tanh((ga_v - 1.2)/1.0) * 0.45; // ~0.55..1.45
  const defense_score = clamp(cs_effect * ga_effect, 0.35, 2.8);
  return defense_score;
}

/* ----------------- Sampling pair (shared component) ----------------- */
function samplePair(lH, lA, rho) {
  const LH = clamp(lH, 0.01, 4.0);
  const LA = clamp(lA, 0.01, 4.0);
  const rho_p = clamp(rho, -0.5, 0.8);

  const shared_base = Math.max(0, Math.min(LH, LA) * Math.abs(rho_p));
  let shared = shared_base;
  if (rho_p < 0) shared = Math.max(0, shared_base * 0.4);

  const s = poisson(shared);
  const rH = poisson(Math.max(0.001, LH - shared));
  const rA = poisson(Math.max(0.001, LA - shared));

  let gh = s + rH;
  let ga = s + rA;

  if (rho_p < 0) {
    // small anti-correlation jitter
    if (Math.random() < 0.5) gh = Math.max(0, gh - Math.round(Math.random()*1));
    else ga = Math.max(0, ga - Math.round(Math.random()*1));
  }

  gh = Math.min(gh, 8);
  ga = Math.min(ga, 8);
  return [gh, ga];
}

/* ----------------- Helpers for impacts (injury) ----------------- */
function totalImpactFromPositions(posChecks, impInputs) {
  let total = 0;
  for (let i=0; i<posChecks.length; i++) {
    if (posChecks[i].checked) total += safe(impInputs[i].value, 0);
  }
  // average of 4 positions, then convert to fraction
  return clamp((total/4)/100, 0, 0.5);
}

/* ----------------- Entropy ----------------- */
function entropy(arr) {
  let e = 0;
  for (let v of arr) if (v>0) e -= v * Math.log2(v);
  return e;
}

/* ----------------- Event handlers: CSR/GA quick calc ----------------- */
// calculate CSR and GA from counts if user fills counts
function calcRatio(count, matches) {
  const c = safe(count, 0);
  const m = safe(matches, 0);
  if (m <= 0) return 0;
  return clamp(c / m, 0, 1);
}

// attach simple buttons behavior (if present)
if (typeof btnCalcCSHome !== 'undefined') btnCalcCSHome.onclick = () => { csHome.value = calcRatio(csCountHome.value, csMatchesHome.value).toFixed(2); };
if (typeof btnCalcCSAway !== 'undefined') btnCalcCSAway.onclick = () => { csAway.value = calcRatio(csCountAway.value, csMatchesAway.value).toFixed(2); };
if (typeof btnCalcGAHome !== 'undefined') btnCalcGAHome.onclick = () => { gcHome.value = (safe(gcHomeCount.value,0) / Math.max(1, safe(gcMatchesHome.value,1))).toFixed(2); };
if (typeof btnCalcGAAway !== 'undefined') btnCalcGAAway.onclick = () => { gcAway.value = (safe(gcAwayCount.value,0) / Math.max(1, safe(gcMatchesAway.value,1))).toFixed(2); };

/* ----------------- Main analysis ----------------- */
btnAnalyze.onclick = () => {
  // --- read inputs ---
  const teamH = teamHome.value || 'Home';
  const teamA = teamAway.value || 'Away';

  const ratingH = safe(ratingHome.value, 6.4);
  const ratingA = safe(ratingAway.value, 6.2);
  const formH = clamp(safe(formHome.value, 0.5), 0, 1);
  const formA = clamp(safe(formAway.value, 0.5), 0, 1);

  const xgH = safe(xgHome.value, ratingH/5);
  const xgA = safe(xgAway.value, ratingA/5);
  const sotH = safe(sotHome.value, 4);
  const sotA = safe(sotAway.value, 3);

  // CSR & GA (use explicit inputs if filled, otherwise compute from counts)
  let csH = safe(csHome.value, NaN);
  if (isNaN(csH)) csH = calcRatio(csCountHome.value, csMatchesHome.value);
  let csA = safe(csAway.value, NaN);
  if (isNaN(csA)) csA = calcRatio(csCountAway.value, csMatchesAway.value);

  let gaH = safe(gcHome.value, NaN);
  if (isNaN(gaH)) gaH = safe(gcHomeCount.value,0) / Math.max(1, safe(gcMatchesHome.value,1));
  let gaA = safe(gcAway.value, NaN);
  if (isNaN(gaA)) gaA = safe(gcAwayCount.value,0) / Math.max(1, safe(gcMatchesAway.value,1));

  // compute base indices
  const atkH = computeAttackIndex(xgH, sotH, formH, ratingH);
  const atkA = computeAttackIndex(xgA, sotA, formA, ratingA);
  const defH = computeDefenseIndex(csH, gaH);
  const defA = computeDefenseIndex(csA, gaA);

  // parameters
  const alphaVal = clamp(safe(alpha.value, 0.15), 0, 0.5);
  const rhoVal = clamp(safe(rho.value, 0.12), -0.5, 0.8);
  const runs = Math.max(1000, parseInt(mcRuns ? mcRuns.value || 40000 : 40000));

  // refined strengths
  let rawH = Math.pow(atkH / defA, 0.88);
  let rawA = Math.pow(atkA / defH, 0.88);

  // shrink toward mutual mean to avoid extreme bias
  const meanRaw = (rawH + rawA) / 2;
  rawH = 0.8 * rawH + 0.2 * meanRaw;
  rawA = 0.8 * rawA + 0.2 * meanRaw;

  // adaptive ratio cap based on rating gap
  const diffRating = Math.abs(ratingH - ratingA);
  const maxRatio = 1.2 + 0.25 * Math.min(diffRating, 1.2);
  if (rawH / rawA > maxRatio) rawH = rawA * maxRatio;
  if (rawA / rawH > maxRatio) rawA = rawH * maxRatio;

  // combine with alpha (shrink toward rating baseline)
  let lH = alphaVal * (ratingH / 5) + (1 - alphaVal) * rawH;
  let lA = alphaVal * (ratingA / 5) + (1 - alphaVal) * rawA;

  // injury impacts per position
  const impHome = totalImpactFromPositions([injHomeGK, injHomeDF, injHomeMF, injHomeFW], [impHomeGK, impHomeDF, impHomeMF, impHomeFW]);
  const impAway = totalImpactFromPositions([injAwayGK, injAwayDF, injAwayMF, injAwayFW], [impAwayGK, impAwayDF, impAwayMF, impAwayFW]);

  const ratingH_eff = ratingH * (1 - impHome);
  const ratingA_eff = ratingA * (1 - impAway);
  const formH_eff = formH * (1 - impHome/2);
  const formA_eff = formA * (1 - impAway/2);

  // softly incorporate effective rating back into lambda
  lH = 0.85 * lH + 0.15 * (ratingH_eff / 5);
  lA = 0.85 * lA + 0.15 * (ratingA_eff / 5);

  // variance balancer
  const adjFactor = 0.35 + 0.3 * Math.abs(formH_eff - formA_eff);
  lH *= (1 - adjFactor/6);
  lA *= (1 - adjFactor/6);

  // small neutral noise to avoid deterministic ties
  const neutralBias = (Math.random()*0.04 - 0.02);
  lH = clamp(lH + neutralBias, 0.18, 3.0);
  lA = clamp(lA - neutralBias, 0.18, 3.0);

  // --- Monte Carlo simulation ---
  let winH = 0, draw = 0, winA = 0;
  const tot = {}; // total goals frequency
  const freq = {}; // score frequency

  for (let i=0; i<runs; i++) {
    const [gh, ga] = samplePair(lH, lA, rhoVal);
    const totalGoals = gh + ga;
    tot[totalGoals] = (tot[totalGoals] || 0) + 1;
    const sc = gh + '-' + ga;
    freq[sc] = (freq[sc] || 0) + 1;

    if (gh > ga) winH++;
    else if (gh === ga) draw++;
    else winA++;
  }

  const pH = winH / runs;
  const pD = draw / runs;
  const pA = winA / runs;

  // Over/Under (raw)
  const ouLineVal = parseFloat(ouLine.value) || 2.5;
  let over = 0, under = 0;
  for (const g in tot) {
    const cnt = tot[g];
    if (Number(g) > ouLineVal) over += cnt;
    else under += cnt;
  }

  // v73: OU soft balancer (pull 15% toward mean)
  const meanOU = (over + under) / 2;
  over = 0.85 * over + 0.15 * meanOU;
  under = 0.85 * under + 0.15 * meanOU;

  const pOver = over / runs;
  const pUnder = under / runs;

  // Handicap cover evaluation (conservative, accounts pushes)
  const hdpRaw = parseFloat(hdpLine.value) || 0;
  let coverSum = 0, pushSum = 0;
  for (const s in freq) {
    const [gh, ga] = s.split('-').map(Number);
    const cnt = freq[s];
    const marginAgainst = gh - ga - hdpRaw;
    if (marginAgainst > 0) coverSum += cnt;
    else if (Math.abs(marginAgainst) < 1e-9) pushSum += cnt;
  }
  const coverH = coverSum / runs;
  const pushH = pushSum / runs;
  const coverA = 1 - coverH - pushH;

  // Market implicit probabilities
  const oddH = safe(hdpHomeNow.value, NaN);
  const oddA = safe(hdpAwayNow.value, NaN);
  const oddOver = safe(ouOverNow.value, NaN);
  const oddUnder = safe(ouUnderNow.value, NaN);
  const impH = oddH ? 1/oddH : NaN;
  const impA = oddA ? 1/oddA : NaN;
  const impO = oddOver ? 1/oddOver : NaN;
  const impU = oddUnder ? 1/oddUnder : NaN;

  function detectTrap(modelProb, impProb) {
    if (isNaN(modelProb) || isNaN(impProb)) return '-';
    const diff = (modelProb - impProb) * 100;
    if (Math.abs(diff) < 2.5) return 'Seimbang (tidak condong)';
    if (diff > 6) return 'Model value (pasar tertinggal)';
    if (diff < -6) return '⚠️ Odds Trap (pasar berat)';
    return diff > 0 ? 'Sedikit value' : 'Sedikit risiko';
  }

  const noteH = detectTrap(coverH, impH);
  const noteO = detectTrap(pOver, impO);

  // Confidence: entropy-aware and conservative
  const ent1x2 = entropy([pH, pD, pA]) / Math.log2(3);
  const entOU = entropy([pOver, pUnder]);
  const top = Math.max(pH, pA, pOver, pUnder);
  let confidenceRaw = top * (1 - 0.6 * ent1x2) * (1 - 0.3 * entOU);
// penalize if market-model disagreement large

  const marketDiscrep = (isNaN(impH) || isNaN(impO)) ? 0 : Math.max(Math.abs((coverH - impH) || 0), Math.abs((pOver - impO) || 0));

  confidenceRaw *= (1 - Math.min(0.15, marketDiscrep));

  const conf = Math.round(clamp(confidenceRaw, 0, 0.95) * 100);



  // --- Output summary ---

  summary.textContent =

`\u03BB Home=${lH.toFixed(2)} \u03BB Away=${lA.toFixed(2)}\n` +

`Prob 1X2 → Home ${pct(pH)} Draw ${pct(pD)} Away ${pct(pA)}\n` +

`OU(${ouLineVal}) → Over ${pct(pOver)} Under ${pct(pUnder)}\n` +

`HDP(${hdpLine.value}) → Home ${pct(coverH)} Away ${pct(coverA)}\n` +

`Confidence: ${conf}%\nAnalisis Pasar:\n- HDP: ${noteH}\n- OU: ${noteO}`;



  // include injury summary

  const injHomeList = (injHomeGK.checked? 'GK ':'') + (injHomeDF.checked? 'DF ':'') + (injHomeMF.checked? 'MF ':'') + (injHomeFW.checked? 'FW ':'');

  const injAwayList = (injAwayGK.checked? 'GK ':'') + (injAwayDF.checked? 'DF ':'') + (injAwayMF.checked? 'MF ':'') + (injAwayFW.checked? 'FW ':'');

  summary.textContent += `\n\nKondisi Cedera:\n- ${teamH}: ${injHomeList.trim() || 'tidak ada'} (impact ${(impHome*100).toFixed(1)}%)\n- ${teamA}: ${injAwayList.trim() || 'tidak ada'} (impact ${(impAway*100).toFixed(1)}%)`;



  // update confidence bar

  confFill.style.width = conf + '%';

  confFill.style.background = conf < 45 ? '#ff4d4d' : conf < 65 ? '#ffb84d' : '#00ff9d';

  confText.textContent = 'Confidence: ' + conf + '%';



  // draw histogram

  const ctx = hist.getContext('2d');

  ctx.clearRect(0,0,520,140);

  const keys = Object.keys(tot).map(k=>+k).sort((a,b)=>a-b);

  if (keys.length>0) {

    const counts = keys.map(k=>tot[k]);

    const maxC = Math.max(...counts);

    const chartW = 480; const left = 20; const bottom = 130;

    const barW = Math.max(12, Math.floor(chartW / keys.length) - 4);

    keys.forEach((k, idx) => {

      const x = left + idx * (barW + 4);

      const h = Math.round((tot[k] / maxC) * 100);

      ctx.fillStyle = '#0b74de'; ctx.fillRect(x, bottom - h, barW, h);

      ctx.fillStyle = '#9fb3c5'; ctx.fillText(k, x, bottom + 10);

    });

  }



  // debug small info

  debug.textContent = `runs=${runs} | lH=${lH.toFixed(2)} lA=${lA.toFixed(2)} | impHome=${(impHome*100).toFixed(1)}% impAway=${(impAway*100).toFixed(1)}%`;

};



/* ----------------- Reset & Download ----------------- */

btnReset.onclick = ()=>{

  // clear inputs but keep simulation params

  const keep = ['alpha','rho','mcRuns','competition'];

  document.querySelectorAll('input,select').forEach(el=>{

    if (keep.indexOf(el.id)===-1) {

      if (el.type==='checkbox') el.checked = false; else el.value = '';

    }

  });

  summary.textContent = 'Klik Analisis untuk hasil.';

  recs.innerHTML = '';

  confFill.style.width = '0%';

  hist.getContext('2d').clearRect(0,0,520,140);

  debug.textContent = '';

};



btnDownload.onclick = ()=>{

  const rows = [];

  rows.push(['match', matchName.value||'', 'date', matchDate.value||'']);

  rows.push(['teamHome', teamHome.value||'', 'teamAway', teamAway.value||'']);

  rows.push(['ratingHome', ratingHome.value||'', 'ratingAway', ratingAway.value||'']);

  rows.push(['formHome', formHome.value||'', 'formAway', formAway.value||'']);

  const csv = rows.map(r=>r.map(c=>`"${(c+'').replace(/"/g,'""')}"`).join(',')).join('\n');

  const blob = new Blob([csv], {type:'text/csv'});

  const url = URL.createObjectURL(blob);

  const a = document.createElement('a'); a.href = url; a.download = 'analysis_export.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);

};

</script>

</body>

</html>

