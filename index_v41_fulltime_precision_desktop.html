<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Prediksi — v41 UltraAI Full-Time Precision (Desktop)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#071026;--panel:#071a29;--accent:#06b6d4;--muted:#9fd6ee;--card:#042033;}
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#eaf6ff;margin:18px}
  h1{font-size:20px;margin:6px 0}
  .grid{display:grid;grid-template-columns:1fr 740px;gap:14px}
  .block{padding:14px;border-radius:10px;border:1px solid #123444;background:var(--panel)}
  label{display:block;font-size:13px;margin:6px 0;color:var(--muted)}
  input[type="number"],input[type="text"],select{width:100%;padding:8px;border:1px solid #1f4254;border-radius:6px;background:#05121a;color:#eaf6ff}
  button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#021825;cursor:pointer;margin-right:6px}
  pre.result{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#031428;padding:12px;border-radius:8px;border:1px dashed #1b6b86;color:#dff7ff}
  .card{background:var(--card);border:1px solid #165a7a;border-radius:8px;padding:10px;margin-top:8px;color:#dff7ff}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{padding:7px;border-bottom:1px solid #0b2f42;text-align:center;font-size:13px;color:#d8f7ff}
  th{background:#052a3a}
  .small{font-size:12px;color:#9fd6ee}
  .muted{color:#88bcd3;font-size:12px}
  .visuals {margin-top:8px}
  canvas {background:#02121a;border-radius:6px;border:1px solid #123b4b}
  .row {display:flex;gap:8px}
  .col {flex:1}
  .log {font-size:12px;color:#cfe8ff;background:#031a24;padding:8px;border-radius:6px;margin-top:8px;white-space:pre-wrap;max-height:220px;overflow:auto}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
</style>
</head>
<body>
<h1>⚽ Prediksi — v41 UltraAI Full-Time Precision</h1>
<p class="small">v41: fokus hanya Full-Time. Ditajamkan dengan Momentum (recent form trend) + Stamina penalty (rest/travel/bench) + finishing variance correction.</p>

<div class="grid">
  <div>
    <div class="block">
      <h3>Input Data (isi sebanyak mungkin)</h3>
      <label>Home Team: <input id="teamHome" type="text" value="Latvia"></label>
      <label>Away Team: <input id="teamAway" type="text" value="Andorra"></label>

      <label class="row"><span class="col">xG: <input id="xgHome" type="number" step="0.01"></span><span class="col"><input id="xgAway" type="number" step="0.01"></span></label>
      <label class="row"><span class="col">xGA: <input id="xgaHome" type="number" step="0.01"></span><span class="col"><input id="xgaAway" type="number" step="0.01"></span></label>
      <label class="row"><span class="col">SOT: <input id="sotHome" type="number" step="0.1"></span><span class="col"><input id="sotAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Goals avg recent: <input id="goalsHome" type="number" step="0.01"></span><span class="col"><input id="goalsAway" type="number" step="0.01"></span></label>

      <label class="small">Skor 5 laga terakhir (contoh: 1,0,2,1,2) — dipakai untuk momentum</label>
      <label class="row"><span class="col">Skor Home: <input id="scoresHome" type="text"></span><span class="col">Skor Away: <input id="scoresAway" type="text"></span></label>

      <label class="row"><span class="col">Conversion Rate: <input id="convHome" type="number" step="0.01"></span><span class="col"><input id="convAway" type="number" step="0.01"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Shot / Set-piece / Tempo / Finishing</h4>
      <label class="row"><span class="col">SQI Home: <input id="sqiHome" type="number" step="0.01" value="1"></span><span class="col">SQI Away: <input id="sqiAway" type="number" step="0.01" value="1"></span></label>
      <label class="row"><span class="col">SPE Home: <input id="speHome" type="number" step="0.01" value="0.5"></span><span class="col">SPE Away: <input id="speAway" type="number" step="0.01" value="0.5"></span></label>
      <label class="row"><span class="col">Tempo Home (0.5-1.5): <input id="tempoHome" type="number" step="0.01" value="1"></span><span class="col">Tempo Away: <input id="tempoAway" type="number" step="0.01" value="1"></span></label>
      <label class="row"><span class="col">Finishing Home (Goals/xG): <input id="finHome" type="number" step="0.01" value="1"></span><span class="col">Finishing Away: <input id="finAway" type="number" step="0.01" value="1"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Def & Tack+Inter</h4>
      <label class="row"><span class="col">Tackles: <input id="tackleHome" type="number" step="0.1"></span><span class="col"><input id="tackleAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Interceptions: <input id="interHome" type="number" step="0.1"></span><span class="col"><input id="interAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Tackles+Inter (TI auto): <input id="tiHome" type="number" readonly></span><span class="col"><input id="tiAway" type="number" readonly></span></label>
      <label class="row"><span class="col">CS /game: <input id="csHome" type="number" step="0.01"></span><span class="col"><input id="csAway" type="number" step="0.01"></span></label>
      <label class="row"><span class="col">GC /game: <input id="gcHome" type="number" step="0.1"></span><span class="col"><input id="gcAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Saves /game: <input id="saveHome" type="number" step="0.1"></span><span class="col"><input id="saveAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Errors->goal est/season: <input id="errHome" type="number" step="0.1"></span><span class="col"><input id="errAway" type="number" step="0.1"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Fatigue / Travel / Bench (stamina)</h4>
      <label class="row"><span class="col">Days rest Home: <input id="daysRestHome" type="number" value="4"></span><span class="col">Days rest Away: <input id="daysRestAway" type="number" value="3"></span></label>
      <label class="row"><span class="col">Travel km Home: <input id="travelKmHome" type="number" value="30"></span><span class="col">Travel km Away: <input id="travelKmAway" type="number" value="600"></span></label>
      <label class="row"><span class="col">Bench depth Home (0-10): <input id="benchHome" type="number" value="5"></span><span class="col">Bench Away: <input id="benchAway" type="number" value="5"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Form / H2H / ELO</h4>
      <label class="row"><span class="col">Form 5 Home: <input id="formRawHome" type="text" placeholder="W,W,D,L,W"></span><span class="col">Form 5 Away: <input id="formRawAway" type="text"></span></label>
      <label>H2H (single field up to 10, W/D/L): <input id="h2hResults" type="text" placeholder="W,D,L,W"></label>
      <label class="row"><span class="col">ELO Home: <input id="eloHome" type="number" value="1400"></span><span class="col">ELO Away: <input id="eloAway" type="number" value="1100"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Odds & Market (Open / Now)</h4>
      <label>HDP Line <input id="hdpLine" type="number" step="0.25" value="0.25"></label>
      <label class="row"><span class="col">HDP Home Open / Now <input id="hdpHomeOpen" type="number" step="0.01"> <input id="hdpHomeNow" type="number" step="0.01"></span><span class="col">HDP Away Open / Now <input id="hdpAwayOpen" type="number" step="0.01"> <input id="hdpAwayNow" type="number" step="0.01"></span></label>
      <label>O/U Line <input id="ouLine" type="number" step="0.25" value="2.5"></label>
      <label class="row"><span class="col">Over Open / Now <input id="ouOverOpen" type="number" step="0.01"> <input id="ouOverNow" type="number" step="0.01"></span><span class="col">Under Open / Now <input id="ouUnderOpen" type="number" step="0.01"> <input id="ouUnderNow" type="number" step="0.01"></span></label>

      <h4>Run & Calibration</h4>
      <label>Monte Carlo runs: <input id="mcRuns" type="number" value="15000"></label>

      <div class="controls">
        <button id="btnAutoCR">Auto CR</button>
        <button id="btnAutoAvgGoals">Auto Avg Goals</button>
        <button id="btnExample">Isi Contoh</button>
        <button id="btnAnalyze">Analisis v41 Full-Time</button>
        <button id="btnReset">Reset</button>
        <button id="btnExportLog">Ekspor Log CSV</button>
      </div>
      <p class="muted">v41 fokus full-time. Momentum + Stamina penalties diaktifkan untuk memperhalus prediksi akhir.</p>
    </div>
  </div>

  <div>
    <div class="block">
      <h3>Ringkasan & Rekomendasi</h3>
      <pre id="summary" class="result">Klik "Analisis v41 Full-Time" untuk hasil...</pre>

      <h3>Rekomendasi Terbaik (Full-Time)</h3>
      <div id="bestRec" class="card">Hasil rekomendasi akan tampil di sini.</div>

      <h3>Trap / Market Table</h3>
      <table id="trapTable"><tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr></table>

      <div class="visuals">
        <h3>📉 Distribusi Skor (Monte Carlo)</h3>
        <canvas id="histMC" width="700" height="160"></canvas>

        <h3>🧠 Confidence Meter</h3>
        <canvas id="confGauge" width="300" height="140"></canvas>
      </div>

      <h3>Log Evaluasi (prediksi vs actual)</h3>
      <div class="log" id="evalLog">Belum ada data.</div>

      <div style="margin-top:8px">
        <input id="actualScore" type="text" placeholder="Masukkan hasil actual 2-2" style="width:60%;padding:6px;border-radius:6px;background:#05121a;color:#eaf6ff;border:1px solid #1f4254">
        <button id="btnEnterActual">Simpan Actual</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Utilities */
function safe(v,d=0){ const x=parseFloat(v); return isNaN(x)?d:x; }
function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
function randNormal(mu=0,sigma=1){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return mu + sigma * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }
function poisson(lambda){ let L=Math.exp(-lambda), p=1, k=0; while(p> L){ k++; p *= Math.random(); if(k>2000) break; } return Math.max(0,k-1); }
function mean(arr){ if(!arr||arr.length===0) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function std(arr){ if(!arr||arr.length===0) return 0; const m=mean(arr); return Math.sqrt(mean(arr.map(x=>Math.pow(x-m,2)))); }
function percent(x){ return (100*x).toFixed(1)+'%'; }
function formScoreFromRaw(raw){ if(!raw) return 0.5; const parts = raw.toUpperCase().replace(/[^WDL,]/g,'').split(',').map(s=>s.trim()).filter(Boolean).slice(0,5); if(parts.length===0) return 0.5; const weights=[0.35,0.25,0.2,0.12,0.08]; let s=0,t=0; for(let i=0;i<parts.length;i++){ const p=parts[i]; let v = p==='W'?1:(p==='D'?0.5:0); s += v*weights[i]; t += weights[i]; } return s/t; }

/* Auto TI and CR, avg goals */
function autoTI(){ tiHome.value = (safe(tackleHome.value)+safe(interHome.value)).toFixed(1); tiAway.value = (safe(tackleAway.value)+safe(interAway.value)).toFixed(1); }
['tackleHome','interHome','tackleAway','interAway'].forEach(id=>document.getElementById(id).addEventListener('input',autoTI));
function autoCR(){ const gh=safe(goalsHome.value,NaN), sh=safe(sotHome.value,NaN); const ga=safe(goalsAway.value,NaN), sa=safe(sotAway.value,NaN); if(sh>0) convHome.value=(gh/sh).toFixed(2); if(sa>0) convAway.value=(ga/sa).toFixed(2); alert('Conversion Rate otomatis diisi.'); }
function autoAvgGoals(){ try{ const p=s=>s.toString().split(',').map(x=>x.trim()).filter(Boolean).map(x=>parseFloat(x)).filter(x=>!isNaN(x)); const h=p(scoresHome.value), a=p(scoresAway.value); if(h.length) goalsHome.value=mean(h).toFixed(2); if(a.length) goalsAway.value=mean(a).toFixed(2); alert('Avg goals terisi.'); }catch(e){ alert('Format skor salah.'); }}

/* Enhanced full-time lambdas: momentum + stamina + finishing variance */
const LEAGUE_PRIOR = 1.25;
const HOME_ADV_DEFAULT = 1.06;

function computeAttack(team){
  const base = 0.42*safe(team.xg,0) + 0.18*(safe(team.sot,0)/5) + 0.10*(safe(team.conv,0)*100) + 0.07*(team.form||0.5) + 0.03*(safe(team.poss,50)/100);
  const sqi = clamp(safe(team.sqi,1),0.5,1.5);
  const spe = clamp(safe(team.spe,0.5),0,1);
  const ft = clamp(safe(team.ft,30)/50,0.2,1.5);
  const tempo = clamp(safe(team.tempo,1),0.6,1.4);
  const fin = clamp(safe(team.fin,1),0.7,1.4);
  const setPieceBoost = 1 + (spe-0.5)*0.12;
  const final = clamp(base * sqi * setPieceBoost * (0.9 + 0.18*ft) * tempo * fin, 0.05, 12.0);
  return {attack:final, sqi, spe, ft, tempo, fin};
}

function computeDefense(team){
  const tiNorm = clamp(safe(team.ti,0)/28,0,2);
  const savesNorm = Math.log(1+Math.max(0,safe(team.saves,0)))/Math.log(7);
  const errAdj = 1 + safe(team.err,7)/40;
  const xgaAdj = 1 + (safe(team.xga,1)-1)*0.12;
  let val = 1 + 0.28*Math.log(Math.max(1,safe(team.gc,0))+1) - 0.27*(safe(team.cs,0)) - 0.13*tiNorm + 0.07*errAdj - 0.11*savesNorm;
  val *= xgaAdj;
  return clamp(val,0.25,5.0);
}

/* Momentum: use weighted recent goals and form trend */
function computeMomentum(scoresHomeRaw, scoresAwayRaw, formH, formA){
  function parseList(s){ return s.toString().split(',').map(x=>x.trim()).filter(Boolean).map(x=>parseFloat(x)).filter(x=>!isNaN(x)); }
  const h = parseList(scoresHomeRaw), a = parseList(scoresAwayRaw);
  const w = [0.40,0.28,0.16,0.10,0.06]; // weights for recent 5 matches
  const scoreWeighted = (arr)=>{ let s=0; for(let i=0;i<Math.min(arr.length,5);i++){ s += (arr[i]||0)*w[i]; } return s; };
  const hw = scoreWeighted(h), aw = scoreWeighted(a);
  const formDiff = formH - formA;
  const momentum = clamp(0.08*formDiff + 0.12*(hw - aw)/Math.max(1, (hw+aw)), -0.18, 0.18);
  return {momentum, hw, aw};
}

/* Stamina penalty: rest, travel, bench => reduces expected goals in FT final output */
function computeStaminaPenalty(daysRest, travelKm, benchDepth){
  const restPenalty = Math.max(0, (3 - daysRest))*0.035; // each day under 3 => 3.5% penalty
  const travelPenalty = Math.max(0, (travelKm - 200))*0.00014; // per km beyond 200
  const benchBonus = Math.max(0, (benchDepth - 5))*0.008; // per bench depth >5 gives small recovery
  const penalty = clamp(1 - restPenalty - travelPenalty + benchBonus, 0.78, 1.06);
  return penalty;
}

function computeLambdasSharpFT(h,a){
  const Ha = computeAttack(h), Aa = computeAttack(a);
  const Hd = computeDefense(h), Ad = computeDefense(a);
  const eloH = clamp(1 + (safe(h.elo,1500)-safe(a.elo,1480))/2400,0.78,1.22);
  const eloA = clamp(1 + (safe(a.elo,1480)-safe(h.elo,1500))/2400,0.78,1.22);
  const homeAdv = HOME_ADV_DEFAULT * (1 + clamp((safe(h.elo,1500)-safe(a.elo,1480))/8000,-0.02,0.02));

  let rawH = ((safe(h.xg,LEAGUE_PRIOR) + safe(h.sot,0)/6)/2) * (Ha.attack / Math.max(0.45, Ad)) * eloH * homeAdv;
  let rawA = ((safe(a.xg,LEAGUE_PRIOR) + safe(a.sot,0)/6)/2) * (Aa.attack / Math.max(0.45, Hd)) * eloA;

  // finishing correction
  rawH *= clamp(1 + (Ha.fin - 1)*0.09, 0.88, 1.28);
  rawA *= clamp(1 + (Aa.fin - 1)*0.09, 0.88, 1.28);

  // momentum effect (based on recent scores + form)
  const mom = computeMomentum(document.getElementById('scoresHome').value, document.getElementById('scoresAway').value, h.form, a.form);
  rawH *= (1 + mom.momentum);
  rawA *= (1 - mom.momentum);

  // stamina penalty based on rest/travel/bench (applies stronger to away)
  const penH = computeStaminaPenalty(safe(document.getElementById('daysRestHome').value,4), safe(document.getElementById('travelKmHome').value,30), safe(document.getElementById('benchHome').value,5));
  const penA = computeStaminaPenalty(safe(document.getElementById('daysRestAway').value,4), safe(document.getElementById('travelKmAway').value,30), safe(document.getElementById('benchAway').value,5));
  rawH *= penH;
  rawA *= penA;

  // absensi cluster & new coach minor adjustments
  rawH *= (1 - 0.05*Math.min(safe(h.absDf,0),4));
  rawA *= (1 - 0.05*Math.min(safe(a.absDf,0),4));
  if(safe(h.newCoach,0)>=1) rawH *= 1.05; if(safe(a.newCoach,0)>=1) rawA *= 1.05;

  // trend & volatility via tempo
  const parseList = s => s.toString().split(',').map(x=>x.trim()).filter(Boolean).map(x=>parseFloat(x)).filter(x=>!isNaN(x));
  const scoresH = parseList(document.getElementById('scoresHome').value);
  const scoresA = parseList(document.getElementById('scoresAway').value);
  const avgRecent = ((scoresH.length?mean(scoresH):safe(h.goals, NaN)) + (scoresA.length?mean(scoresA):safe(a.goals, NaN))) / 2;
  const leagueAvg = Math.max(0.6,(safe(h.xg,LEAGUE_PRIOR) + safe(a.xg,LEAGUE_PRIOR))/2);
  rawH *= 1 + 0.10*(avgRecent - leagueAvg);
  rawA *= 1 + 0.10*(avgRecent - leagueAvg);

  const volH = scoresH.length? Math.min(1.1, 0.06 + std(scoresH)/Math.max(0.1,mean(scoresH))) : 0.06;
  const volA = scoresA.length? Math.min(1.1, 0.06 + std(scoresA)/Math.max(0.1,mean(scoresA))) : 0.06;

  const quality= (()=>{ let q=0; [h.xg,a.xg,h.sot,a.sot,h.cs,a.cs].forEach(v=>{ if(v && v>0) q+=1; }); return q/6; })();
  const shrinkW = clamp(0.55 + 0.4*quality,0.45,0.95);
  let lambdaH = shrinkW*rawH + (1-shrinkW)*LEAGUE_PRIOR;
  let lambdaA = shrinkW*rawA + (1-shrinkW)*LEAGUE_PRIOR;

  const avg = (lambdaH + lambdaA)/2;
  if(avg > 4.2){ lambdaH *= 0.80; lambdaA *= 0.80; } else if(avg > 3.0){ lambdaH *= 0.92; lambdaA *= 0.92; }
  lambdaH *= 0.995; lambdaA *= 0.995;

  return {lambdaH:Math.max(0.01,lambdaH), lambdaA:Math.max(0.01,lambdaA), atkH:Ha.attack, atkA:Aa.attack, defH:Hd, defA:Ad, volH, volA, momentum: mom};
}

/* Monte Carlo and helpers */
function sampleLogPoisson(lambdaH,lambdaA,rho,sigma){
  const z1 = randNormal(0,sigma);
  const z2 = rho*z1 + Math.sqrt(Math.max(0,1-rho*rho))*randNormal(0,sigma);
  const lH = Math.max(0.01, lambdaH * Math.exp(z1 - 0.5*sigma*sigma));
  const lA = Math.max(0.01, lambdaA * Math.exp(z2 - 0.5*sigma*sigma));
  return [poisson(lH), poisson(lA)];
}
function monteCarlo(lambdaH,lambdaA,rho,sigmaFactor,volFactor,runs){
  const freq={}, totals={}; let home=0,draw=0,away=0;
  const sigma = clamp(0.10 + sigmaFactor*0.28 + volFactor*0.14, 0.06, 1.1);
  for(let i=0;i<runs;i++){
    const [gh,ga] = sampleLogPoisson(lambdaH,lambdaA,rho,sigma);
    const k=`${gh}-${ga}`; freq[k]=(freq[k]||0)+1; totals[gh+ga]=(totals[gh+ga]||0)+1;
    if(gh>ga) home++; else if(gh===ga) draw++; else away++;
  }
  return {freq, totals, pHome:home/runs, pDraw:draw/runs, pAway:away/runs};
}

/* Confidence */
function computeConfidence(totals){ let meanT=0,varv=0,count=0; for(const t in totals){ const g=parseInt(t), v=totals[t]; meanT += g*v; count += v; } if(count===0) return {score:0.5,label:'Low'}; meanT /= count; for(const t in totals){ const g=parseInt(t), v=totals[t]; varv += ((g-meanT)**2)*v; } varv /= count; let conf = clamp(1 - Math.min(1,varv/8), 0.15, 0.98); const label = conf>0.80? 'High' : (conf>0.55? 'Medium' : 'Low'); return {score:conf,label}; }

/* Dynamic bias */
function dynamicBiasAdj(){ try{ const logs = JSON.parse(localStorage.getItem('v41_logs')||'[]'); const recent = logs.slice(0,25); if(recent.length===0) return 1.0; let sumPred=0,sumAct=0,c=0; recent.forEach(r=>{ if(r.pred && r.pred.avgTotal && r.actual && typeof r.actual.total==='number'){ sumPred += r.pred.avgTotal; sumAct += r.actual.total; c++; } }); if(c===0) return 1.0; const ratio = (sumAct / sumPred) || 1.0; return clamp(ratio, 0.85, 1.15); }catch(e){ return 1.0; }}

/* Main analyze full-time */
function analyzeV41(){
  const runs = Math.max(2000, safe(mcRuns.value,15000));
  const h = { xg: safe(xgHome.value,1.1), xga: safe(xgaHome.value,1.1), sot: safe(sotHome.value,3.4), conv: clamp(safe(convHome.value,0.12),0,1), poss: safe(ftHome.value,30), ti: safe(tiHome.value,25), cs: safe(csHome.value,0.32), gc: safe(gcHome.value,1.2), saves: safe(saveHome.value,3.6), err: safe(errHome.value,7), formRaw: formRawHome.value||'', form: Number.isFinite(parseFloat(formHome.value))? safe(formHome.value): null, absDf: safe(absDfHome.value,0), benchDepth: safe(benchHome.value,5), elo: safe(eloHome.value,1500), goals: safe(goalsHome.value,NaN), sqi: safe(sqiHome.value,1), spe: safe(speHome.value,0.5), ft: safe(ftHome.value,30), tempo: safe(tempoHome.value,1), fin: safe(finHome.value,1)};
  const a = { xg: safe(xgAway.value,1.0), xga: safe(xgaAway.value,1.0), sot: safe(sotAway.value,3.0), conv: clamp(safe(convAway.value,0.11),0,1), poss: safe(ftAway.value,28), ti: safe(tiAway.value,20), cs: safe(csAway.value,0.28), gc: safe(gcAway.value,1.3), saves: safe(saveAway.value,3.7), err: safe(errAway.value,8), formRaw: formRawAway.value||'', form: Number.isFinite(parseFloat(formAway.value))? safe(formAway.value): null, absDf: safe(absDfAway.value,0), benchDepth: safe(benchAway.value,5), elo: safe(eloAway.value,1480), goals: safe(goalsAway.value,NaN), sqi: safe(sqiAway.value,1), spe: safe(speAway.value,0.5), ft: safe(ftAway.value,28), tempo: safe(tempoAway.value,1), fin: safe(finAway.value,1)};
  h.form = (Number.isFinite(h.form) && h.form>0)? clamp(h.form,0,1): (formScoreFromRaw(h.formRaw) || 0.5);
  a.form = (Number.isFinite(a.form) && a.form>0)? clamp(a.form,0,1): (formScoreFromRaw(a.formRaw) || 0.5);

  const biasAdj = dynamicBiasAdj();
  const r = computeLambdasSharpFT(h,a);
  let lambdaH = r.lambdaH * biasAdj, lambdaA = r.lambdaA * biasAdj;

  const diffElo = Math.abs(safe(h.elo,1500)-safe(a.elo,1500));
  let rho = clamp(0.05 + 0.18 * (diffElo/800) + 0.12 * Math.abs(h.form - a.form), 0.03, 0.5);

  const sigmaFactor = clamp((Math.abs(h.form - a.form) + Math.abs(h.xg - a.xg))/4,0,1);
  const volFactor = clamp((r.volH + r.volA)/2,0,1);
  const mc = monteCarlo(lambdaH, lambdaA, rho, sigmaFactor, volFactor, runs);

  const avgH = Object.entries(mc.freq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[0])*v,0)/runs;
  const avgA = Object.entries(mc.freq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[1])*v,0)/runs;

  // OU & HDP probabilities
  const ouLine = safe(ouLine.value,2.5);
  function probOUFromTotals(totals,line,runs){ let over=0,under=0; const isInt = Number.isInteger(line); for(const t in totals){ const g=parseInt(t), v=totals[t]; if(isInt){ if(g>line) over+=v; else if(g<line) under+=v; else { over+=0.5*v; under+=0.5*v; } } else { if(g>line) over+=v; else under+=v; } } return {over: over/runs, under: under/runs}; }
  const ouProb = probOUFromTotals(mc.totals, ouLine, runs);
  const hdpLine = safe(hdpLine.value,0.25);
  function probCoverFromScores(scoreFreq,handicap,runs){ let win=0,push=0,lose=0; for(const sc in scoreFreq){ const v=scoreFreq[sc]; const [gh,ga]=sc.split('-').map(x=>parseInt(x)); const diff=gh-ga-handicap; if(diff>0) win+=v; else if(diff===0) push+=v; else lose+=v; } return (win + 0.5*push)/runs; }
  const coverHome = probCoverFromScores(mc.freq, hdpLine, runs);
  const coverAway = probCoverFromScores(mc.freq, -hdpLine, runs);

  // implied market probs (if provided)
  function impliedProb(odds){ if(!odds||odds<=0) return null; return 1/odds; }
  const implied = { ouOver: impliedProb(safe(ouOverNow.value,NaN)), ouUnder: impliedProb(safe(ouUnderNow.value,NaN)), hdpHome: impliedProb(safe(hdpHomeNow.value,NaN)), hdpAway: impliedProb(safe(hdpAwayNow.value,NaN)) };

  // hybrid blend: model + market weighted by confidence
  const conf = computeConfidence(mc.totals);
  const alpha = clamp(conf.score, 0.25, 0.92);
  const final_over = (implied.ouOver? (alpha*ouProb.over + (1-alpha)*implied.ouOver) : ouProb.over);
  const final_under = 1 - final_over;
  const final_hdpHome = (implied.hdpHome? (alpha*coverHome + (1-alpha)*implied.hdpHome) : coverHome);
  const final_hdpAway = (implied.hdpAway? (alpha*coverAway + (1-alpha)*implied.hdpAway) : coverAway);

  // candidates & edges
  const candidates = [
    {tag:`OU Over ${ouLine}`, prob:final_over, market:'OU', open:safe(ouOverOpen.value,NaN), now:safe(ouOverNow.value,NaN)},
    {tag:`OU Under ${ouLine}`, prob:final_under, market:'OU', open:safe(ouUnderOpen.value,NaN), now:safe(ouUnderNow.value,NaN)},
    {tag:`HDP Home ${hdpLine}`, prob:final_hdpHome, market:'HDP', open:safe(hdpHomeOpen.value,NaN), now:safe(hdpHomeNow.value,NaN)},
    {tag:`HDP Away ${-hdpLine}`, prob:final_hdpAway, market:'HDP', open:safe(hdpAwayOpen.value,NaN), now:safe(hdpAwayNow.value,NaN)}
  ];
  candidates.forEach(c=>{ c.edge = c.open? (c.prob - (1/c.open)) : null; c.delta = (c.open && c.now)? ((c.now - c.open)/c.open*100): null; c.status = (c.delta===null? {label:'N/A'} : (Math.abs(c.delta)>=15?{label:'Trap'}:(Math.abs(c.delta)>=5?{label:'Warning'}:{label:'Stable'}))); });

  candidates.sort((a,b)=>b.prob - a.prob);
  const selected = candidates.slice(0,2).map(c=>{ let signal='Low'; if(c.prob>=0.60 && c.edge!==null && c.edge>=0.015) signal='High'; else if(c.prob>=0.55 && c.edge!==null && c.edge>=0.01) signal='Medium'; return {...c,signal}; });

  // summary text
  let summary = `λ (FT sharp): Home ${lambdaH.toFixed(2)} | Away ${lambdaA.toFixed(2)} (biasAdj ${biasAdj.toFixed(3)})\n`;
  summary += `Attack idx H:${r.atkH.toFixed(2)} A:${r.atkA.toFixed(2)} | Def idx H:${r.defH.toFixed(2)} A:${r.defA.toFixed(2)}\n`;
  summary += `Momentum H:${r.momentum.hw.toFixed(2)} A:${r.momentum.aw.toFixed(2)} | momFactor:${r.momentum.momentum.toFixed(3)}\n`;
  summary += `Exp goals(sim): H ${avgH.toFixed(2)} | A ${avgA.toFixed(2)}\n`;
  summary += `Prob 1X2 — Home ${(100*mc.pHome).toFixed(1)}% Draw ${(100*mc.pDraw).toFixed(1)}% Away ${(100*mc.pAway).toFixed(1)}%\n`;
  summary += `OU(${ouLine}) → Over ${percent(final_over)} | Under ${percent(final_under)}\n`;
  summary += `HDP(${hdpLine}) → Home ${percent(final_hdpHome)} | Away ${percent(final_hdpAway)}\n`;
  summary += `Confidence: ${conf.label} (${(100*conf.score).toFixed(1)}%)\n`;
  document.getElementById('summary').textContent = summary;

  // render recommendations
  let html=''; selected.forEach(s=>{ const arrow = (s.signal==='High')? '📈' : (s.signal==='Medium'? '⚠️' : ''); html += `<div class="card"><div style="font-weight:700">${s.tag}</div><div class="small">Δ:${s.delta? s.delta.toFixed(1)+'%':''} • Status:${s.status.label}</div><div style="float:right;text-align:right">${percent(s.prob)}<br>${s.edge?((s.edge*100).toFixed(2)+'% edge'):'-'}<div style="margin-top:6px">${s.signal} ${arrow}</div></div><div style="clear:both"></div></div>`; });
  document.getElementById('bestRec').innerHTML = html || '<div class="small">Tidak ada rekomendasi signifikan.</div>';

  // trap table
  let table = '<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr>';
  candidates.forEach(c=>{ table += `<tr><td>${c.tag}</td><td>${c.open||''}</td><td>${c.now||''}</td><td>${c.delta?c.delta.toFixed(1)+'%':''}</td><td>${c.now && c.open ? (c.now<c.open? 'Money → Favor':'Money → Against') : ''}</td><td>${percent(c.prob)}</td><td>${c.edge?((c.edge*100).toFixed(2)+'%'):'-'}</td><td>${c.status.label}</td></tr>`; });
  document.getElementById('trapTable').innerHTML = table;

  // visuals
  drawHistogram(mc.totals, ouLine);
  drawGauge(conf);

  // store last prediction for evaluation
  window._lastPrediction = {lambdaH,lambdaA,avgH,avgA,pHome:mc.pHome,pDraw:mc.pDraw,pAway:mc.pAway,ou:{line:ouLine,over:final_over,under:final_under},hdp:{line:hdpLine,home:final_hdpHome,away:final_hdpAway},freq:mc.freq};

  return {mc, candidates, conf, biasAdj};
}

/* Visuals */
function drawHistogram(totals, ouLine){
  try{
    const canvas=document.getElementById('histMC'); const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const keys=Object.keys(totals).map(x=>parseInt(x)).sort((a,b)=>a-b);
    if(keys.length===0) return;
    const maxV=Math.max(...keys.map(k=>totals[k]||0),1);
    const pad=30; const w=(canvas.width-pad*2)/Math.max(1,keys.length);
    keys.forEach((k,i)=>{ const v=totals[k]||0; const h=(v/maxV)*(canvas.height-60); ctx.fillStyle=(k<=ouLine)?'#3fa34d':'#de3f3f'; ctx.fillRect(pad+i*w,canvas.height-40-h,Math.max(6,w-6),h); ctx.fillStyle='#9fd6ee'; ctx.font='11px Arial'; ctx.fillText(String(k),pad+i*w,canvas.height-18); });
  }catch(e){}
}
function drawGauge(conf){
  try{
    const canvas=document.getElementById('confGauge'); const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx=canvas.width/2, cy=canvas.height*0.85, r=Math.min(canvas.width,canvas.height)*0.34;
    ctx.beginPath(); ctx.lineWidth=14; ctx.strokeStyle='#082733'; ctx.arc(cx,cy,r,Math.PI,2*Math.PI,false); ctx.stroke();
    const val=clamp(conf.score,0,1), end= Math.PI + val*Math.PI;
    ctx.beginPath(); ctx.lineWidth=14; ctx.strokeStyle = val>0.8? '#2dd36f' : (val>0.55? '#f7b731' : '#eb3b5a'); ctx.arc(cx,cy,r,Math.PI,end,false); ctx.stroke();
    ctx.font='16px Arial'; ctx.fillStyle='#cfe8ff'; ctx.textAlign='center'; ctx.fillText((val*100).toFixed(1)+'%',cx,cy-r-6); ctx.font='12px Arial'; ctx.fillText(conf.label,cx,cy-r+12);
  }catch(e){} 
}

/* Logging */
const LOG_KEY = 'v41_logs';
function saveLogEntry(pred, actual, meta){
  const logs = JSON.parse(localStorage.getItem(LOG_KEY)||'[]');
  logs.unshift({time:new Date().toISOString(), match:`${teamHome.value} vs ${teamAway.value}`, pred, actual, meta});
  if(logs.length>1000) logs.pop();
  localStorage.setItem(LOG_KEY, JSON.stringify(logs));
  renderEvalLog();
}
function renderEvalLog(){ const logs = JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); const el=document.getElementById('evalLog'); if(logs.length===0){ el.textContent='Belum ada data.'; return;} let txt=''; logs.forEach(l=>{ txt += `${l.time} | ${l.match} | Pred:${JSON.stringify(l.pred)} | Act:${JSON.stringify(l.actual)}\n`; }); el.textContent=txt; }
function exportLogsCSV(){ const logs=JSON.parse(localStorage.getItem(LOG_KEY)||'[]'); if(logs.length===0){ alert('Tidak ada log'); return; } const header=['time','match','pred','actual','meta']; const rows=logs.map(r=>[r.time,r.match,JSON.stringify(r.pred),JSON.stringify(r.actual),JSON.stringify(r.meta)]); const csv=[header.join(','), ...rows.map(r=> r.map(c=>`"${(String(c)).replace(/"/g,'""')}"`).join(','))].join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='v41_eval_log.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

/* UI wiring */
document.getElementById('btnAnalyze').addEventListener('click', ()=>{ try{ const out = analyzeV41(); saveLogEntry(out, null, {note:'predicted'}); }catch(e){ alert('Error saat analisis: '+e.message); } });
document.getElementById('btnAutoCR').addEventListener('click', autoCR);
document.getElementById('btnAutoAvgGoals').addEventListener('click', autoAvgGoals);
document.getElementById('btnExample').addEventListener('click', ()=>{
  teamHome.value='Latvia'; teamAway.value='Andorra'; h2hResults.value='D,L,D'; xgHome.value=1.05; xgaHome.value=1.2; xgAway.value=0.45; xgaAway.value=1.8; sotHome.value=4.1; sotAway.value=1.8; scoresHome.value='1,0,2,1,2'; scoresAway.value='0,1,0,2,1'; convHome.value=''; convAway.value=''; possHome.value=56; possAway.value=44; tackleHome.value=18; interHome.value=8; tackleAway.value=12; interAway.value=6; autoTI(); csHome.value=0.30; csAway.value=0.10; gcHome.value=1.05; gcAway.value=1.8; saveHome.value=3.1; saveAway.value=2.5; errHome.value=6; errAway.value=5; formRawHome.value='W,D,L,W,D'; formRawAway.value='L,L,D,W,D'; absDfHome.value=0; absMfHome.value=1; absFwHome.value=0; absDfAway.value=1; absMfAway.value=0; absFwAway.value=0; benchHome.value=5; benchAway.value=3; sqiHome.value=1; sqiAway.value=0.9; speHome.value=0.45; speAway.value=0.4; ftHome.value=35; ftAway.value=25; tempoHome.value=1.05; tempoAway.value=0.92; finHome.value=1.08; finAway.value=0.87; daysRestHome.value=5; daysRestAway.value=2; travelKmHome.value=40; travelKmAway.value=480; hdpLine.value=0.25; hdpHomeOpen.value=1.90; hdpHomeNow.value=1.95; hdpAwayOpen.value=1.95; hdpAwayNow.value=1.85; ouLine.value=2.5; ouOverOpen.value=1.95; ouOverNow.value=1.88; ouUnderOpen.value=1.90; ouUnderNow.value=2.00; mcRuns.value=15000; alert('Contoh terisi. Klik Analisis v41 Full-Time.'); });
document.getElementById('btnReset').addEventListener('click', ()=>{ document.querySelectorAll('input').forEach(i=>{ if(i.type!=='button') i.value=''; if(i.type==='checkbox') i.checked=false; }); document.getElementById('summary').textContent='Direset.'; document.getElementById('bestRec').innerHTML='Hasil rekomendasi akan tampil di sini.'; document.getElementById('trapTable').innerHTML='<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr>'; renderEvalLog(); const ctx=document.getElementById('histMC').getContext('2d'); ctx.clearRect(0,0,700,160); const ctx2=document.getElementById('confGauge').getContext('2d'); ctx2.clearRect(0,0,300,140); window._lastPrediction=null; });
document.getElementById('btnEnterActual').addEventListener('click', ()=>{ const txt=document.getElementById('actualScore').value.trim(); if(!txt){ alert('Masukkan hasil actual. Format: gh-ga (contoh 2-2)'); return; } const parts=txt.split('-').map(x=>parseInt(x.trim())); if(parts.length!==2||isNaN(parts[0])||isNaN(parts[1])){ alert('Format salah.'); return; } if(!window._lastPrediction){ alert('Belum ada prediksi. Klik Analisis dulu.'); return; } const actual={gh:parts[0], ga:parts[1], total: parts[0]+parts[1]}; const pred={avgH: window._lastPrediction.avgH, avgA: window._lastPrediction.avgA, avgTotal: (window._lastPrediction.avgH + window._lastPrediction.avgA)}; saveLogEntry(pred, actual, {note:'actual_entered'}); alert('Actual disimpan ke log evaluasi.'); });
document.getElementById('btnExportLog').addEventListener('click', exportLogsCSV);

renderEvalLog();
</script>
</body>
</html>