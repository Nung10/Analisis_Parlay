<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Prediksi — v29.6 Ultra Precision AutoCR (Full)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0d0f10;--panel:#141618;--muted:#9aa3ad;--card-hdp:#165c35;--card-ou:#0b74de}
  body{font-family:Inter,Arial,Helvetica,sans-serif;margin:18px;background:var(--bg);color:#eef2f3}
  h1{font-size:20px;margin:0 0 6px 0}
  .grid{display:grid;grid-template-columns:1fr 640px;gap:14px}
  .block{padding:12px;border-radius:10px;border:1px solid #222;background:var(--panel)}
  label{display:block;font-size:13px;margin:8px 0}
  input[type="number"],input[type="text"],select{width:100%;padding:8px;border:1px solid #333;border-radius:6px;background:#0f1315;color:#fff;font-size:13px}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0b74de;color:#fff;cursor:pointer;margin:4px;font-weight:600}
  .small{font-size:12px;color:var(--muted)}
  .result{white-space:pre-wrap;font-family:monospace;background:#0b0d0f;padding:10px;border-radius:8px;border:1px dashed #222;margin-top:8px;color:#dfeefd}
  table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
  th,td{padding:6px;border-bottom:1px solid #1f2224;text-align:center}
  th{background:#0d0f11}
  .card{padding:12px;border-radius:10px;color:#fff;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center}
  .card-left{max-width:68%}
  .card-hdp{background:linear-gradient(90deg,var(--card-hdp),#11512a);border:1px solid rgba(255,255,255,0.04)}
  .card-ou{background:linear-gradient(90deg,var(--card-ou),#094f9b);border:1px solid rgba(255,255,255,0.04)}
  .confidence-up{color:#a6ffb0;font-weight:700}
  .confidence-down{color:#ffb0b0;font-weight:700}
  .status-red{background:#c23a3a;color:#fff;padding:6px 8px;border-radius:6px}
  .status-yellow{background:#b79e20;color:#111;padding:6px 8px;border-radius:6px}
  .status-green{background:#1e8e3e;color:#fff;padding:6px 8px;border-radius:6px}
  .anomaly{padding:10px;border-radius:8px;background:#3b1a1a;color:#fff;margin-bottom:8px;font-weight:bold}
  canvas{background:#070809;border-radius:6px;border:1px solid #0b212f}
  .inline-note{font-size:12px;color:var(--muted);margin-left:8px}
  .controls{display:flex;gap:6px;flex-wrap:wrap}
  .mini-bar{height:8px;background:#111;border-radius:4px;overflow:hidden;width:120px;display:inline-block;vertical-align:middle}
  .mini-bar > span{display:block;height:8px;border-radius:4px}
  .footer-note{font-size:12px;color:#7e8a8d;margin-top:8px}
</style>
</head>
<body>
<h1>⚽ Prediksi — v29.6 Ultra Precision AutoCR (Full)</h1>
<p class="small">Versi penuh: Auto CR, Auto TI, Odds Trap Pro, Market Anomaly, Histogram, Precision+ Monte Carlo, rekomendasi card & confidence.</p>

<div class="grid">
  <div>
    <div class="block">
      <h3>Input Utama</h3>
      <label>Home Team: <input id="teamHome" type="text" value="Home FC"></label>
      <label>Away Team: <input id="teamAway" type="text" value="Away FC"></label>

      <label>H2H (5 hasil, contoh WDLWL): <input id="h2hResults" type="text" maxlength="5"></label>

      <label>xG per Game: <input id="xgHome" type="number" step="0.01"> <input id="xgAway" type="number" step="0.01"></label>
      <label>Shots on Target (SOT): <input id="sotHome" type="number" step="0.1"> <input id="sotAway" type="number" step="0.1"></label>
      <label>Goals (untuk Auto CR): <input id="goalsHome" type="number" step="1"> <input id="goalsAway" type="number" step="1"></label>
      <label>Conversion Rate (0–1): <input id="convHome" type="number" step="0.01"> <input id="convAway" type="number" step="0.01"></label>

      <label>Big chances / Missed: <input id="bigHome" type="number" step="0.1"> <input id="missHome" type="number" step="0.1"> <input id="bigAway" type="number" step="0.1"> <input id="missAway" type="number" step="0.1"></label>

      <label>Tackles: <input id="tackleHome" type="number" step="0.1"> <input id="tackleAway" type="number" step="0.1"></label>
      <label>Interceptions: <input id="interHome" type="number" step="0.1"> <input id="interAway" type="number" step="0.1"></label>
      <label>Tackles + Interceptions <span class="inline-note">(otomatis)</span>: <input id="tiHome" type="number" readonly> <input id="tiAway" type="number" readonly></label>

      <label>Possession %: <input id="possHome" type="number" step="0.1"> <input id="possAway" type="number" step="0.1"></label>

      <h4>Defending Metrics</h4>
      <label>Clean Sheet / Game: <input id="csHome" type="number" step="0.01"> <input id="csAway" type="number" step="0.01"></label>
      <label>Goals Conceded / Game: <input id="gcHome" type="number" step="0.1"> <input id="gcAway" type="number" step="0.1"></label>
      <label>Saves / Game: <input id="saveHome" type="number" step="0.1"> <input id="saveAway" type="number" step="0.1"></label>
      <label>Errors leading to goal / season (est): <input id="errHome" type="number" step="0.1"> <input id="errAway" type="number" step="0.1"></label>

      <label>Performa 5 laga (W,D,W,L,D) atau skor (0-1): <input id="formRawHome" type="text" placeholder="W,D,W,D,W"> <input id="formRawAway" type="text"></label>
      <label>Atau skor performa (0–1): <input id="formHome" type="number" step="0.01"> <input id="formAway" type="number" step="0.01"></label>

      <h4>Absensi posisi (jumlah)</h4>
      <label>Home — Defender <input id="absDfHome" type="number" step="1" min="0"> Midfielder <input id="absMfHome" type="number" step="1" min="0"> Forward <input id="absFwHome" type="number" step="1" min="0"></label>
      <label>Away — Defender <input id="absDfAway" type="number" step="1" min="0"> Midfielder <input id="absMfAway" type="number" step="1" min="0"> Forward <input id="absFwAway" type="number" step="1" min="0"></label>

      <label>ELO Rating: <input id="eloHome" type="number" value="1500"> <input id="eloAway" type="number" value="1480"></label>

      <h4>Odds (HDP + OU) — Open & Now</h4>
      <label>HDP Line <input id="hdpLine" type="number" step="0.25" value="0.25"></label>
      <label>Home Open <input id="hdpHomeOpen" type="number" step="0.01"> Home Now <input id="hdpHomeNow" type="number" step="0.01"> | Away Open <input id="hdpAwayOpen" type="number" step="0.01"> Away Now <input id="hdpAwayNow" type="number" step="0.01"></label>

      <label>OU Line <input id="ouLine" type="number" step="0.25" value="2.5"></label>
      <label>Over Open <input id="ouOverOpen" type="number" step="0.01"> Over Now <input id="ouOverNow" type="number" step="0.01"> | Under Open <input id="ouUnderOpen" type="number" step="0.01"> Under Now <input id="ouUnderNow" type="number" step="0.01"></label>

      <label>Monte Carlo runs: <input id="mcRuns" type="number" value="8000" step="100"></label>

      <div style="margin-top:10px" class="controls">
        <button id="btnExample">Isi Contoh</button>
        <button id="btnAutoCR">Hitung CR Otomatis</button>
        <button id="btnReset">Reset</button>
        <button id="btnAnalyze">Analisis Ultra Precision</button>
      </div>
      <div class="small" style="margin-top:6px">Tips: isi Goals & SOT → lalu klik "Hitung CR Otomatis".</div>
    </div>
  </div>

  <div>
    <div class="block">
      <div id="anomalyTop" style="display:none" class="anomaly"></div>

      <h3>Rekomendasi Terbaik</h3>
      <div id="bestRec">
        <div class="result">Klik "Analisis Ultra Precision" untuk rekomendasi.</div>
      </div>

      <h3>Ringkasan</h3>
      <div id="summary" class="result">Ringkasan hasil muncul di sini.</div>

      <h3>Odds Trap & Market Moves (Pro)</h3>
      <table id="trapTable"><tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob Model</th><th>Edge%</th><th>Status</th></tr></table>

      <h3>Histogram Total Gol</h3>
      <canvas id="hist" width="520" height="140"></canvas>

      <div id="debug" class="result small">--</div>
    </div>
  </div>
</div>

<script>
// --- Utilities
function safe(v,d=0){const x=parseFloat(v);return isNaN(x)?d:x;}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function randNormal(mu=0,sigma=1){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return mu+sigma*Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
function poisson(k){let L=Math.exp(-k),p=1,c=0;while(p>L){c++;p*=Math.random();if(c>1000)break;}return c-1;}
function ln(x){return Math.log(Math.max(1e-6,x));}
function percent(x){return (100*x).toFixed(1)+'%';}

// --- Auto TI
function autoTI(){ tiHome.value = (safe(tackleHome.value)+safe(interHome.value)).toFixed(1); tiAway.value = (safe(tackleAway.value)+safe(interAway.value)).toFixed(1); }
['tackleHome','interHome','tackleAway','interAway'].forEach(id=>document.getElementById(id).addEventListener('input',autoTI));

// --- Auto CR
function autoCR(){
  const gh = safe(goalsHome.value, NaN), sh = safe(sotHome.value, NaN);
  const ga = safe(goalsAway.value, NaN), sa = safe(sotAway.value, NaN);
  if(sh>0) convHome.value = (gh/sh).toFixed(2);
  if(sa>0) convAway.value = (ga/sa).toFixed(2);
  alert('Conversion Rate otomatis terisi dari Goals ÷ SOT.');
}

// --- Form parser
function formScoreFromRaw(raw){
  if(!raw) return null;
  const parts = raw.toString().split(',').map(s=>s.trim().toUpperCase()).filter(Boolean).slice(0,5);
  if(parts.length===0) return null;
  const weights = [0.35,0.25,0.20,0.12,0.08];
  let score=0,total=0;
  for(let i=0;i<parts.length;i++){ const p=parts[i]; let val=0; if(p==='W') val=1; else if(p==='D') val=0.5; score+=val*weights[i]; total+=weights[i]; }
  return score/total;
}

// --- Precision+ calculations (attack, defense, lambdas) ---
function computeAttackSharp(team){
  const sotFactor = Math.min(1.2, 1 + Math.max(0, (team.sot - 4))/15);
  const possFactor = Math.min(1.15, 1 + Math.max(0, (team.poss - 50))/200);
  const bigChanceFactor = 1 + Math.max(0, (team.big||0) - (team.miss||0))*0.03;
  const base = 0.35*team.xg + 0.25*(team.sot/5) + 0.15*(team.conv*100) + 0.10*(team.form||0.5);
  const missPenalty = 0.06*(team.miss||0)/3;
  const dynamic = (sotFactor * possFactor * bigChanceFactor) - 1.0;
  const attack = Math.max(0.15, base - missPenalty) * (1 + dynamic*0.12);
  return attack;
}
function computeDefenseSharp(team){
  const errPerGame = safe(team.err,7)/38.0;
  const savesFactor = Math.log(1 + Math.max(0, team.saves))/Math.log(1+6);
  let val = 1 + (0.28 * ln(team.gc + 1)) - 0.20*team.cs - 0.10*(team.ti/25) + 0.05*(team.absDf||0) + 0.03*errPerGame - 0.08*savesFactor;
  return clamp(val,0.45,2.8);
}
function computeLambdasSharp(h,a){
  const atkH = computeAttackSharp(h), atkA = computeAttackSharp(a);
  const defH = computeDefenseSharp(h), defA = computeDefenseSharp(a);
  const sfH = clamp(1 + (h.elo - a.elo)/1400, 0.75, 1.25);
  const sfA = clamp(1 + (a.elo - h.elo)/1400, 0.75, 1.25);
  const leagueAvg = Math.max(0.6, (h.xg + a.xg)/2);

  let lambdaH = leagueAvg * (atkH / Math.max(0.3, leagueAvg)) * (1/defA) * sfH;
  let lambdaA = leagueAvg * (atkA / Math.max(0.3, leagueAvg)) * (1/defH) * sfA;

  const h2hRaw = (function(s){ if(!s) return 0; const t=s.toUpperCase().replace(/[^WDL]/g,'').slice(0,5); if(!t) return 0; let w=(t.match(/W/g)||[]).length; let l=(t.match(/L/g)||[]).length; return (w - l)/Math.max(1,t.length); })(h.h2h||'');
  const momentum = 0.15*(h.form - a.form) + 0.05*h2hRaw;
  lambdaH *= (1 + momentum);
  lambdaA *= (1 - momentum);

  const penaltyH = 1 - (0.04*(h.absDf||0) + 0.03*(h.absMf||0) + 0.05*(h.absFw||0));
  const penaltyA = 1 - (0.04*(a.absDf||0) + 0.03*(a.absMf||0) + 0.05*(a.absFw||0));
  const pH = clamp(penaltyH,0.7,1.0), pA = clamp(penaltyA,0.7,1.0);
  lambdaH *= pH; lambdaA *= pA;

  const avgLam = (lambdaH + lambdaA)/2;
  if(avgLam > 3.0){ lambdaH *= 0.86; lambdaA *= 0.86; } else if(avgLam > 2.0){ lambdaH *= 0.94; lambdaA *= 0.94; }

  const shrinkW = 0.55;
  lambdaH = shrinkW*lambdaH + (1-shrinkW)*h.xg;
  lambdaA = shrinkW*lambdaA + (1-shrinkW)*a.xg;

  lambdaH *= 0.99; lambdaA *= 0.99;

  return {lambdaH, lambdaA, atkH, atkA, defH, defA};
}

// --- Monte Carlo adaptive sampling
function sampleBivarAdaptive(lambdaH,lambdaA,rho,sigmaFactor){
  const sigma = 0.22 + sigmaFactor*0.12;
  const z1 = randNormal(0,sigma); const z2 = rho*z1 + Math.sqrt(Math.max(0,1-rho*rho))*randNormal(0,sigma);
  const lamH = Math.max(0.01, lambdaH * Math.exp(z1 - 0.5*sigma*sigma));
  const lamA = Math.max(0.01, lambdaA * Math.exp(z2 - 0.5*sigma*sigma));
  return [poisson(lamH), poisson(lamA)];
}
function monteCarloAdaptive(lambdaH,lambdaA,rho,sigmaFactor,runs){
  const scoreFreq={}, totals={}; let h=0,d=0,a=0;
  for(let i=0;i<runs;i++){
    const [gh,ga] = sampleBivarAdaptive(lambdaH,lambdaA,rho,sigmaFactor);
    const key = `${gh}-${ga}`;
    scoreFreq[key] = (scoreFreq[key]||0) + 1;
    totals[gh+ga] = (totals[gh+ga]||0) + 1;
    if(gh>ga) h++; else if(gh===ga) d++; else a++;
  }
  return {scoreFreq,totals,pHome:h/runs,pDraw:d/runs,pAway:a/runs};
}

// --- Probabilities helpers
function probCoverFromScores(scoreFreq,handicap,runs){
  let win=0,push=0,lose=0;
  for(const sc in scoreFreq){
    const v = scoreFreq[sc];
    const [gh,ga] = sc.split('-').map(x=>parseInt(x));
    const diff = gh - ga - handicap;
    if(diff>0) win+=v; else if(diff===0) push+=v; else lose+=v;
  }
  return (win + 0.5*push)/runs;
}
function probOUFromTotals(totals,line,runs){
  let over=0,under=0;
  const isInt = Number.isInteger(line);
  for(const t in totals){
    const g = parseInt(t), v = totals[t];
    if(isInt){
      if(g>line) over+=v; else if(g<line) under+=v; else { over+=0.5*v; under+=0.5*v; }
    } else {
      if(g>line) over+=v; else under+=v;
    }
  }
  return {over: over/runs, under: under/runs};
}
function impliedProb(odds){ if(!odds||odds<=0) return null; return 1/odds; }
function shrinkEdge(e){ if(e===null) return null; const cap=0.22; return Math.sign(e)*Math.min(Math.abs(e),cap); }
function deltaPercent(open,now){ if(!open || !now) return null; return ((now - open)/open*100); }
function directionLabel(open,now,market){
  if(!open || !now) return '';
  const diff = now - open;
  if(market==='OU'){
    if(diff < -0.03) return 'Money → Over';
    if(diff > 0.03) return 'Money → Under';
    return 'Stable';
  } else if(market==='HDP'){
    if(diff < -0.03) return 'Money → Home';
    if(diff > 0.03) return 'Money → Away';
    return 'Stable';
  }
  return '';
}
function statusFromDelta(d){ if(d===null) return {label:'N/A',className:''}; const ad=Math.abs(d); if(ad>=15) return {label:'Trap',className:'status-red'}; if(ad>=5) return {label:'Warning',className:'status-yellow'}; return {label:'Stable',className:'status-green'}; }

// --- Confidence calibration with market influence
function computeConfidenceAdaptive(totals, candidates){
  let mean=0,varv=0,count=0;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; mean += g*v; count += v; }
  if(count===0) return {score:0.5,label:'Low'};
  mean /= count;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; varv += ((g-mean)**2)*v; }
  varv /= count;
  let conf = clamp(1 - Math.min(1, varv/8), 0.15, 0.97);
  let trapCount=0; candidates.forEach(c=>{ if(c.status && c.status.label==='Trap') trapCount++; });
  if(trapCount>=2) conf *= 0.85;
  const allStable = candidates.every(c=> c.status && c.status.label==='Stable');
  if(allStable) conf = Math.min(0.99, conf * 1.08);
  const label = conf>0.8? 'High' : (conf>0.55? 'Medium' : 'Low');
  return {score:conf,label};
}

// --- Main analysis (full)
function analyzeUltraPrecisionAutoCR(){
  const runs = Math.max(2000, safe(mcRuns.value,8000));
  const rho = 0.12;

  const h = {
    xg: safe(xgHome.value,1.1), sot: safe(sotHome.value,3.4), conv: clamp(safe(convHome.value,0.12),0,1),
    big: safe(bigHome.value,0), miss: safe(missHome.value,0), poss: safe(possHome.value,52),
    ti: safe(tiHome.value,25), cs: safe(csHome.value,0.32), gc: safe(gcHome.value,1.2), saves: safe(saveHome.value,3.6), err: safe(errHome.value,7),
    formRaw: formRawHome.value||'', form: Number.isFinite(parseFloat(formHome.value))? safe(formHome.value): null,
    absDf: safe(absDfHome.value,0), absMf: safe(absMfHome.value,0), absFw: safe(absFwHome.value,0),
    elo: safe(eloHome.value,1500)
  };
  const a = {
    xg: safe(xgAway.value,1.0), sot: safe(sotAway.value,3.0), conv: clamp(safe(convAway.value,0.11),0,1),
    big: safe(bigAway.value,0), miss: safe(missAway.value,0), poss: safe(possAway.value,48),
    ti: safe(tiAway.value,20), cs: safe(csAway.value,0.28), gc: safe(gcAway.value,1.3), saves: safe(saveAway.value,3.7), err: safe(errAway.value,8),
    formRaw: formRawAway.value||'', form: Number.isFinite(parseFloat(formAway.value))? safe(formAway.value): null,
    absDf: safe(absDfAway.value,0), absMf: safe(absMfAway.value,0), absFw: safe(absFwAway.value,0),
    elo: safe(eloAway.value,1480)
  };

  // derive form & h2h
  h.form = (Number.isFinite(h.form) && h.form>0)? clamp(h.form,0,1): (formScoreFromRaw(h.formRaw) || 0.5);
  a.form = (Number.isFinite(a.form) && a.form>0)? clamp(a.form,0,1): (formScoreFromRaw(a.formRaw) || 0.5);
  h.h2h = h2hResults.value||''; a.h2h = h2hResults.value||'';

  if(!Number.isFinite(h.ti) || h.ti===0) h.ti = safe(tackleHome.value,0) + safe(interHome.value,0);
  if(!Number.isFinite(a.ti) || a.ti===0) a.ti = safe(tackleAway.value,0) + safe(interAway.value,0);

  const r = computeLambdasSharp(h,a);
  let lambdaH = r.lambdaH, lambdaA = r.lambdaA, atkH=r.atkH, atkA=r.atkA, defH=r.defH, defA=r.defA;

  const formSpread = Math.abs(h.form - a.form);
  const xgSpread = Math.abs(h.xg - a.xg);
  const sigmaFactor = clamp((formSpread + xgSpread)/4, 0, 1);

  const mc = monteCarloAdaptive(lambdaH,lambdaA,rho,sigmaFactor,runs);

  const avgH = Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[0])*v,0)/runs;
  const avgA = Object.entries(mc.scoreFreq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[1])*v,0)/runs;

  const ouLine = safe(ouLine.value,2.5);
  const ouProb = probOUFromTotals(mc.totals,ouLine,runs);

  const hdpLine = safe(hdpLine.value,0.25);
  const coverHome = probCoverFromScores(mc.scoreFreq, hdpLine, runs);
  const coverAway = probCoverFromScores(mc.scoreFreq, -hdpLine, runs);

  const implied = {
    ouOver: impliedProb(safe(ouOverNow.value,NaN)),
    ouUnder: impliedProb(safe(ouUnderNow.value,NaN)),
    hdpHome: impliedProb(safe(hdpHomeNow.value,NaN)),
    hdpAway: impliedProb(safe(hdpAwayNow.value,NaN))
  };
  const edges = {
    ouOver: (implied.ouOver? (ouProb.over - implied.ouOver) : null),
    ouUnder: (implied.ouUnder? (ouProb.under - implied.ouUnder) : null),
    hdpHome: (implied.hdpHome? (coverHome - implied.hdpHome) : null),
    hdpAway: (implied.hdpAway? (coverAway - implied.hdpAway) : null)
  };

  const candidates = [
    {tag:`OU Over ${ouLine}`, prob:ouProb.over, edge:edges.ouOver, desc:`Over ${ouLine}`, market:'OU', open:safe(ouOverOpen.value,NaN), now:safe(ouOverNow.value,NaN)},
    {tag:`OU Under ${ouLine}`, prob:ouProb.under, edge:edges.ouUnder, desc:`Under ${ouLine}`, market:'OU', open:safe(ouUnderOpen.value,NaN), now:safe(ouUnderNow.value,NaN)},
    {tag:`HDP Home ${hdpLine}`, prob:coverHome, edge:edges.hdpHome, desc:`Home covers ${hdpLine}`, market:'HDP', open:safe(hdpHomeOpen.value,NaN), now:safe(hdpHomeNow.value,NaN)},
    {tag:`HDP Away ${-hdpLine}`, prob:coverAway, edge:edges.hdpAway, desc:`Away covers ${-hdpLine}`, market:'HDP', open:safe(hdpAwayOpen.value,NaN), now:safe(hdpAwayNow.value,NaN)}
  ];
  candidates.forEach(c=>{
    c.edgeShr = (c.edge===null? null: shrinkEdge(c.edge));
    c.score = ((c.edgeShr||0)*(c.prob||0)) + (c.prob*0.62);
    c.delta = deltaPercent(c.open,c.now);
    c.direction = directionLabel(c.open,c.now,c.market);
    c.status = statusFromDelta(c.delta);
  });

  candidates.sort((a,b)=>b.score - a.score);
  const selected = candidates.slice(0,2).map(c=>{
    let signal='Low';
    if(c.prob>=0.58 && c.edgeShr!==null && c.edgeShr>=0.015) signal='High';
    else if(c.prob>=0.54 && c.edgeShr!==null && c.edgeShr>=0.01) signal='Medium';
    return {...c,signal};
  });

  const conf = computeConfidenceAdaptive(mc.totals, candidates);

  // build summary
  let summaryTxt = `λ (sharp): Home ${lambdaH.toFixed(2)} | Away ${lambdaA.toFixed(2)}\n`;
  summaryTxt += `Attack idx H:${atkH.toFixed(2)} A:${atkA.toFixed(2)} | Defense idx H:${defH.toFixed(2)} A:${defA.toFixed(2)}\n`;
  summaryTxt += `Exp Goals (sim): H ${avgH.toFixed(2)} | A ${avgA.toFixed(2)}\n`;
  summaryTxt += `Prob 1X2 — Home ${(100*mc.pHome).toFixed(1)}% Draw ${(100*mc.pDraw).toFixed(1)}% Away ${(100*mc.pAway).toFixed(1)}%\n`;
  summaryTxt += `OU (Line ${ouLine}) → Over ${percent(ouProb.over)} | Under ${percent(ouProb.under)}\n`;
  summaryTxt += `HDP (Line ${hdpLine}) → Home ${percent(coverHome)} | Away ${percent(coverAway)}\n`;
  summaryTxt += `Confidence: ${conf.label} (${(100*conf.score).toFixed(1)}%)\n`;

  document.getElementById('summary').textContent = summaryTxt;

  // anomaly detection
  let redCount=0, contradictory=0;
  candidates.forEach(c=>{
    if(c.status && c.status.label==='Trap') redCount++;
    if(c.edgeShr!==null){
      if(c.market==='OU' && c.edgeShr>0 && c.direction==='Money → Under') contradictory++;
      if(c.market==='HDP' && c.edgeShr>0 && c.direction==='Money → Away') contradictory++;
    }
  });
  const anomaly = (redCount>=2 || contradictory>=1);
  const anomalyEl = document.getElementById('anomalyTop');
  if(anomaly){
    anomalyEl.style.display='block';
    anomalyEl.innerHTML = '⚠️ Market anomaly detected — hindari pasar langsung, evaluasi lebih lanjut.';
  } else { anomalyEl.style.display='none'; anomalyEl.innerHTML=''; }

  // render recommendations as cards
  let recHtml='';
  selected.forEach((s,i)=>{
    const cls = s.tag.startsWith('HDP')? 'card-hdp' : 'card-ou';
    const arrow = (conf.score>0.6 && s.signal==='High')? '📈 Confidence ↑' : (conf.score<0.45 && s.signal==='Low'? '📉 Confidence ↓' : '');
    const confClass = arrow.includes('↑')? 'confidence-up' : (arrow.includes('↓')? 'confidence-down' : '');
    recHtml += `<div class="card ${cls}"><div class="card-left"><div style="font-weight:700;font-size:15px">${s.tag}</div><div class="small" style="margin-top:4px">${s.desc} • Market: ${s.direction}</div></div><div style="text-align:right"><div style="font-size:18px">${percent(s.prob)}</div><div style="font-size:12px;margin-top:4px">${s.edgeShr!==null? ((s.edgeShr*100).toFixed(2)+'% edge') : 'No market odds'}</div><div style="margin-top:8px" class="${confClass}">${s.signal}${arrow? ' • '+arrow: ''}</div></div></div>`;
  });
  document.getElementById('bestRec').innerHTML = recHtml;

  // trap table
  let table = '<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob Model</th><th>Edge%</th><th>Status</th></tr>';
  candidates.forEach(c=>{
    const delta = c.delta===null? '': c.delta.toFixed(1)+'%';
    const edgeTxt = c.edgeShr===null? '-' : ( (c.edgeShr*100).toFixed(2) + '%' );
    const statusLabel = c.status.label;
    table += `<tr><td>${c.tag}</td><td>${c.open||''}</td><td>${c.now||''}</td><td>${delta}</td><td>${c.direction}</td><td>${percent(c.prob)}</td><td>${edgeTxt}</td><td>${statusLabel}</td></tr>`;
  });
  document.getElementById('trapTable').innerHTML = table;

  // histogram
  const ctx = document.getElementById('hist').getContext('2d'); ctx.clearRect(0,0,520,140);
  const keys = Object.keys(mc.totals).map(x=>parseInt(x)).sort((a,b)=>a-b);
  const maxV = Math.max(...keys.map(k=>mc.totals[k]||0),1);
  const margin = 10, totalW = 500, w = Math.max(18, (totalW - margin)/Math.max(1,keys.length));
  keys.forEach((k,i)=>{
    const hgt = (mc.totals[k]/maxV)*110;
    ctx.fillStyle = '#0b74de';
    ctx.fillRect(margin + i*w, 120 - hgt, w-6, hgt);
    ctx.fillStyle='#9fb3c5';
    ctx.font='10px Arial';
    ctx.fillText(String(k), margin + i*w, 136);
  });

  document.getElementById('debug').textContent = `sigmaFactor:${sigmaFactor.toFixed(2)} avgH:${avgH.toFixed(2)} avgA:${avgA.toFixed(2)} redCount:${redCount} contradictory:${contradictory}`;
}

// --- UI: example & reset
function fillExample(){
  teamHome.value='Man City'; teamAway.value='Tottenham'; h2hResults.value='WDWLW';
  xgHome.value=2.1; xgAway.value=1.4; sotHome.value=6.2; sotAway.value=4.1; goalsHome.value=8; goalsAway.value=6;
  convHome.value=''; convAway.value=''; bigHome.value=3; missHome.value=1; bigAway.value=1; missAway.value=2;
  possHome.value=62; possAway.value=38;
  tackleHome.value=22; interHome.value=9; tackleAway.value=17; interAway.value=7; autoTI();
  csHome.value=0.48; csAway.value=0.30; gcHome.value=0.8; gcAway.value=1.3; saveHome.value=3.6; saveAway.value=3.2;
  errHome.value=5; errAway.value=9; formRawHome.value='W,W,D,W,L'; formRawAway.value='L,D,W,L,D'; formHome.value=''; formAway.value='';
  absDfHome.value=1; absMfHome.value=0; absFwHome.value=1; absDfAway.value=0; absMfAway.value=2; absFwAway.value=0;
  eloHome.value=1820; eloAway.value=1690;
  hdpLine.value=0.25; hdpHomeOpen.value=1.95; hdpHomeNow.value=1.88; hdpAwayOpen.value=1.95; hdpAwayNow.value=2.05;
  ouLine.value=2.5; ouOverOpen.value=1.95; ouOverNow.value=1.88; ouUnderOpen.value=1.90; ouUnderNow.value=2.00;
  mcRuns.value=8000;
  alert('Contoh terisi. Klik Hitung CR Otomatis lalu Analisis Ultra Precision.');
}
function resetAll(){
  document.querySelectorAll('input').forEach(i=>{ if(i.type!=='button') i.value=''; });
  document.getElementById('summary').textContent='Direset.';
  document.getElementById('bestRec').innerHTML='<div class="result">--</div>';
  document.getElementById('trapTable').innerHTML='<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob Model</th><th>Edge%</th><th>Status</th></tr>';
  const ctx=document.getElementById('hist').getContext('2d'); ctx.clearRect(0,0,520,140);
  document.getElementById('anomalyTop').style.display='none';
}
document.getElementById('btnAnalyze').addEventListener('click',analyzeUltraPrecisionAutoCR);
document.getElementById('btnExample').addEventListener('click',fillExample);
document.getElementById('btnReset').addEventListener('click',resetAll);
document.getElementById('btnAutoCR').addEventListener('click',autoCR);

</script>
</body>
</html>
