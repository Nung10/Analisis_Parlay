<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Prediksi — v39 UltraAI (Desktop Full)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#071026;--panel:#071a29;--accent:#06b6d4;--muted:#9fd6ee;--card:#042033;}
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#eaf6ff;margin:18px}
  h1{font-size:20px;margin:6px 0}
  .grid{display:grid;grid-template-columns:1fr 640px;gap:14px}
  .block{padding:14px;border-radius:10px;border:1px solid #123444;background:var(--panel)}
  label{display:block;font-size:13px;margin:6px 0;color:var(--muted)}
  input[type="number"],input[type="text"],select{width:100%;padding:8px;border:1px solid #1f4254;border-radius:6px;background:#05121a;color:#eaf6ff}
  button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#021825;cursor:pointer;margin-right:6px}
  pre.result{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#031428;padding:12px;border-radius:8px;border:1px dashed #1b6b86;color:#dff7ff}
  .card{background:var(--card);border:1px solid #165a7a;border-radius:8px;padding:10px;margin-top:8px;color:#dff7ff}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{padding:7px;border-bottom:1px solid #0b2f42;text-align:center;font-size:13px;color:#d8f7ff}
  th{background:#052a3a}
  .small{font-size:12px;color:#9fd6ee}
  .muted{color:#88bcd3;font-size:12px}
  .visuals {margin-top:8px}
  canvas {background:#02121a;border-radius:6px;border:1px solid #123b4b}
  .row {display:flex;gap:8px}
  .col {flex:1}
  .log {font-size:12px;color:#cfe8ff;background:#031a24;padding:8px;border-radius:6px;margin-top:8px;white-space:pre-wrap;max-height:220px;overflow:auto}
  .inline {display:inline-block;margin-right:8px}
  .small-muted{font-size:11px;color:#7fb6cf}
  .foot{font-size:12px;color:#9fd6ee;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:6px;background:#0b3b4a;color:#bff0ff;font-size:12px}
</style>
</head>
<body>
<h1>⚽ Prediksi — v39 UltraAI (Desktop Full)</h1>
<p class="small">v39 UltraAI: SQI, SPE, PTW, Fatigue, 2H tactics, Motivation, Coach Impact, Injury Cluster, Dynamic Calibration, Adaptive Rho, Market hybrid, Log & Export.</p>

<div class="grid">
  <div>
    <div class="block">
      <h3>Input Data (isi sebanyak mungkin)</h3>
      <label>Home Team: <input id="teamHome" type="text" value="Latvia"></label>
      <label>Away Team: <input id="teamAway" type="text" value="Andorra"></label>

      <label class="row"><span class="col">xG: <input id="xgHome" type="number" step="0.01"></span><span class="col"><input id="xgAway" type="number" step="0.01"></span></label>
      <label class="row"><span class="col">SOT: <input id="sotHome" type="number" step="0.1"></span><span class="col"><input id="sotAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Goals avg recent: <input id="goalsHome" type="number" step="0.01"></span><span class="col"><input id="goalsAway" type="number" step="0.01"></span></label>

      <label class="small">Skor 5 laga terakhir (contoh: 1,0,2,1,2)</label>
      <label class="row"><span class="col">Skor Home: <input id="scoresHome" type="text"></span><span class="col">Skor Away: <input id="scoresAway" type="text"></span></label>

      <label class="row"><span class="col">Conversion Rate: <input id="convHome" type="number" step="0.01"></span><span class="col"><input id="convAway" type="number" step="0.01"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Shot / Set-piece (SQI / SPE / PTW)</h4>
      <label class="row"><span class="col">Shot Quality Index (SQI) Home (0.5-1.5): <input id="sqiHome" type="number" step="0.01" value="1"></span><span class="col">SQI Away: <input id="sqiAway" type="number" step="0.01" value="1"></span></label>
      <label class="row"><span class="col">SetPiece Efficiency (SPE 0-1) Home: <input id="speHome" type="number" step="0.01" value="0.5"></span><span class="col">SPE Away: <input id="speAway" type="number" step="0.01" value="0.5"></span></label>
      <label class="row"><span class="col">FinalThird Poss % Home: <input id="ftHome" type="number" step="0.1" value="30"></span><span class="col">FT Away: <input id="ftAway" type="number" step="0.1" value="28"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Defending & TI</h4>
      <label class="row"><span class="col">Tackles: <input id="tackleHome" type="number" step="0.1"></span><span class="col"><input id="tackleAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Interceptions: <input id="interHome" type="number" step="0.1"></span><span class="col"><input id="interAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Tackles+Inter (TI auto): <input id="tiHome" type="number" readonly></span><span class="col"><input id="tiAway" type="number" readonly></span></label>
      <label class="row"><span class="col">Clean sheet /game: <input id="csHome" type="number" step="0.01"></span><span class="col"><input id="csAway" type="number" step="0.01"></span></label>
      <label class="row"><span class="col">Goals conceded /game: <input id="gcHome" type="number" step="0.1"></span><span class="col"><input id="gcAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Saves /game: <input id="saveHome" type="number" step="0.1"></span><span class="col"><input id="saveAway" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Errors->goal est/season: <input id="errHome" type="number" step="0.1"></span><span class="col"><input id="errAway" type="number" step="0.1"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Fatigue, Travel & 2H Tactics</h4>
      <label class="row"><span class="col">Days rest Home: <input id="daysRestHome" type="number" value="4"></span><span class="col">Days rest Away: <input id="daysRestAway" type="number" value="3"></span></label>
      <label class="row"><span class="col">Travel km Home: <input id="travelKmHome" type="number" value="30"></span><span class="col">Travel km Away: <input id="travelKmAway" type="number" value="600"></span></label>
      <label class="row"><span class="col">Goals 1H Home: <input id="g1hHome" type="number" step="0.1"></span><span class="col">Goals 2H Home: <input id="g2hHome" type="number" step="0.1"></span></label>
      <label class="row"><span class="col">Goals 1H Away: <input id="g1hAway" type="number" step="0.1"></span><span class="col">Goals 2H Away: <input id="g2hAway" type="number" step="0.1"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Motivation / Coach / Crowd</h4>
      <label class="row"><span class="col">Motivation Home (0-2): <input id="motHome" type="number" step="0.01" value="1"></span><span class="col">Mot Away: <input id="motAway" type="number" step="0.01" value="1"></span></label>
      <label class="row"><span class="col">Coach Impact Home (0.8-1.4): <input id="coachHome" type="number" step="0.01" value="1"></span><span class="col">Coach Away: <input id="coachAway" type="number" step="0.01" value="1"></span></label>
      <label class="row"><span class="col">Crowd factor Home (0.8-1.2): <input id="crowdHome" type="number" step="0.01" value="1"></span><span class="col">Crowd Away: <input id="crowdAway" type="number" step="0.01" value="1"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Absensi & Bench</h4>
      <label class="row"><span class="col">DF abs Home: <input id="absDfHome" type="number" value="0"></span><span class="col">DF abs Away: <input id="absDfAway" type="number" value="0"></span></label>
      <label class="row"><span class="col">MF abs Home: <input id="absMfHome" type="number" value="0"></span><span class="col">MF abs Away: <input id="absMfAway" type="number" value="0"></span></label>
      <label class="row"><span class="col">FW abs Home: <input id="absFwHome" type="number" value="0"></span><span class="col">FW abs Away: <input id="absFwAway" type="number" value="0"></span></label>
      <label class="row"><span class="col">Bench depth Home (0-10): <input id="benchHome" type="number" value="5"></span><span class="col">Bench Away: <input id="benchAway" type="number" value="5"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Form / H2H / ELO</h4>
      <label class="row"><span class="col">Form 5 Home: <input id="formRawHome" type="text" placeholder="W,W,D,L,W"></span><span class="col">Form 5 Away: <input id="formRawAway" type="text"></span></label>
      <label>H2H (single field up to 10, W/D/L): <input id="h2hResults" type="text" placeholder="W,D,L,W"></label>
      <label class="row"><span class="col">ELO Home: <input id="eloHome" type="number" value="1400"></span><span class="col">ELO Away: <input id="eloAway" type="number" value="1100"></span></label>

      <hr style="border:none;border-top:1px solid #0b2f42;margin:8px 0">

      <h4>Odds & Market</h4>
      <label>HDP Line <input id="hdpLine" type="number" step="0.25" value="0.25"></label>
      <label class="row"><span class="col">HDP Home Open / Now <input id="hdpHomeOpen" type="number" step="0.01"> <input id="hdpHomeNow" type="number" step="0.01"></span><span class="col">HDP Away Open / Now <input id="hdpAwayOpen" type="number" step="0.01"> <input id="hdpAwayNow" type="number" step="0.01"></span></label>
      <label>O/U Line <input id="ouLine" type="number" step="0.25" value="2.5"></label>
      <label class="row"><span class="col">Over Open / Now <input id="ouOverOpen" type="number" step="0.01"> <input id="ouOverNow" type="number" step="0.01"></span><span class="col">Under Open / Now <input id="ouUnderOpen" type="number" step="0.01"> <input id="ouUnderNow" type="number" step="0.01"></span></label>

      <h4>Weather</h4>
      <label class="row"><span class="col">Temp °C: <input id="temp" type="number" step="0.1"></span><span class="col">Rain (0/1): <input id="rain" type="number" step="1" value="0"></span></label>

      <h4>Run & Calibration</h4>
      <label>Monte Carlo runs: <input id="mcRuns" type="number" value="15000"></label>
      <label class="row"><span class="col">Platt a (over): <input id="plattA_over" type="number" step="0.001"></span><span class="col">Platt b (over): <input id="plattB_over" type="number" step="0.001"></span></label>
      <label class="row"><span class="col">Platt a (hdp): <input id="plattA_hdp" type="number" step="0.001"></span><span class="col">Platt b (hdp): <input id="plattB_hdp" type="number" step="0.001"></span></label>

      <div class="controls">
        <button id="btnAutoCR">Auto CR</button>
        <button id="btnAutoAvgGoals">Auto Avg Goals</button>
        <button id="btnExample">Isi Contoh</button>
        <button id="btnAnalyze">Analisis v39 UltraAI</button>
        <button id="btnReset">Reset</button>
        <button id="btnExportLog">Ekspor Log CSV</button>
      </div>

      <p class="muted">Isi data sedetail mungkin: SQI, SPE, FinalThird, TI, CS, absensi, ELO, dan odds Open/Now.</p>
    </div>
  </div>

  <div>
    <div class="block">
      <h3>Ringkasan & Rekomendasi</h3>
      <pre id="summary" class="result">Klik "Analisis v39 UltraAI" untuk hasil...</pre>

      <h3>Rekomendasi Terbaik (Hybrid)</h3>
      <div id="bestRec" class="card">Hasil rekomendasi akan tampil di sini.</div>

      <h3>Trap / Market Table</h3>
      <table id="trapTable"><tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr></table>

      <div class="visuals">
        <h3>📉 Distribusi Skor (Monte Carlo)</h3>
        <canvas id="histMC" width="600" height="160"></canvas>

        <h3>🧠 Confidence Meter</h3>
        <canvas id="confGauge" width="260" height="140"></canvas>
      </div>

      <h3>Log Evaluasi (prediksi vs actual)</h3>
      <div class="log" id="evalLog">Belum ada data.</div>

      <div style="margin-top:8px">
        <input id="actualScore" type="text" placeholder="Masukkan hasil actual 2-2" style="width:60%;padding:6px;border-radius:6px;background:#05121a;color:#eaf6ff;border:1px solid #1f4254">
        <button id="btnEnterActual">Simpan Actual</button>
      </div>

      <div class="foot">
        <div class="small-muted">Log evaluasi disimpan di localStorage; klik "Ekspor Log CSV" untuk mendownload.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* Utilities */
function safe(v,d=0){ const x=parseFloat(v); return isNaN(x)?d:x; }
function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
function randNormal(mu=0,sigma=1){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return mu + sigma * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }
function poisson(lambda){ let L=Math.exp(-lambda), p=1, k=0; while(p> L){ k++; p *= Math.random(); if(k>2000) break; } return Math.max(0,k-1); }
function mean(arr){ if(!arr||arr.length===0) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function std(arr){ if(!arr||arr.length===0) return 0; const m=mean(arr); return Math.sqrt(mean(arr.map(x=>Math.pow(x-m,2)))); }
function percent(x){ return (100*x).toFixed(1)+'%'; }
function formScoreFromRaw(raw){ if(!raw) return 0.5; const parts = raw.toUpperCase().replace(/[^WDL,]/g,'').split(',').map(s=>s.trim()).filter(Boolean).slice(0,5); if(parts.length===0) return 0.5; const weights=[0.35,0.25,0.2,0.12,0.08]; let s=0,t=0; for(let i=0;i<parts.length;i++){ const p=parts[i]; let v = p==='W'?1:(p==='D'?0.5:0); s += v*weights[i]; t += weights[i]; } return s/t; }

/* Auto TI and CR, avg goals */
function autoTI(){ tiHome.value = (safe(tackleHome.value)+safe(interHome.value)).toFixed(1); tiAway.value = (safe(tackleAway.value)+safe(interAway.value)).toFixed(1); }
['tackleHome','interHome','tackleAway','interAway'].forEach(id=>document.getElementById(id).addEventListener('input',autoTI));
function autoCR(){ const gh=safe(goalsHome.value,NaN), sh=safe(sotHome.value,NaN); const ga=safe(goalsAway.value,NaN), sa=safe(sotAway.value,NaN); if(sh>0) convHome.value=(gh/sh).toFixed(2); if(sa>0) convAway.value=(ga/sa).toFixed(2); alert('Conversion Rate otomatis diisi.'); }
function autoAvgGoals(){ try{ const p=s=>s.toString().split(',').map(x=>x.trim()).filter(Boolean).map(x=>parseFloat(x)).filter(x=>!isNaN(x)); const h=p(scoresHome.value), a=p(scoresAway.value); if(h.length) goalsHome.value=mean(h).toFixed(2); if(a.length) goalsAway.value=mean(a).toFixed(2); alert('Avg goals terisi.'); }catch(e){ alert('Format skor salah.'); }}

/* Core enhanced model */
const LEAGUE_PRIOR = 1.25;
const HOME_ADV_DEFAULT = 1.06;

function computeAttack(team){
  const base = 0.45*safe(team.xg,0) + 0.18*(safe(team.sot,0)/5) + 0.10*(safe(team.conv,0)*100) + 0.08*(team.form||0.5) + 0.04*(safe(team.poss,50)/100);
  const sqi = clamp(safe(team.sqi,1),0.5,1.5);
  const spe = clamp(safe(team.spe,0.5),0,1);
  const ft = clamp(safe(team.ft,30)/50,0.2,1.5);
  const setPieceBoost = 1 + (spe-0.5)*0.12;
  const final = clamp(base * sqi * setPieceBoost * (0.9 + 0.2*ft), 0.05, 9.0);
  return {attack:final, sqi, spe, ft};
}

function computeDefense(team){
  const tiNorm = clamp(safe(team.ti,0)/28,0,2);
  const savesNorm = Math.log(1+Math.max(0,safe(team.saves,0)))/Math.log(7);
  const errAdj = 1 + safe(team.err,7)/40;
  let val = 1 + 0.28*Math.log(Math.max(1,safe(team.gc,0))+1) - 0.27*(safe(team.cs,0)) - 0.13*tiNorm + 0.07*errAdj - 0.11*savesNorm;
  if(team.xga !== undefined) val *= (1 + (safe(team.xga,1)-1)*0.08);
  return clamp(val,0.25,4.5);
}

function computeLambdas(h,a){
  const Ha = computeAttack(h), Aa = computeAttack(a);
  const Hd = computeDefense(h), Ad = computeDefense(a);
  const eloH = clamp(1 + (safe(h.elo,1500)-safe(a.elo,1480))/2400,0.78,1.22);
  const eloA = clamp(1 + (safe(a.elo,1480)-safe(h.elo,1500))/2400,0.78,1.22);
  const homeAdv = HOME_ADV_DEFAULT * (1 + clamp((safe(h.elo,1500)-safe(a.elo,1480))/8000,-0.02,0.02));
  let rawH = ((safe(h.xg,LEAGUE_PRIOR) + safe(h.sot,0)/6)/2) * (Ha.attack / Math.max(0.45, Ad)) * eloH * homeAdv;
  let rawA = ((safe(a.xg,LEAGUE_PRIOR) + safe(a.sot,0)/6)/2) * (Aa.attack / Math.max(0.45, Hd)) * eloA;

  const defCluster = Math.min(safe(h.absDf,0),4);
  rawH *= (1 - 0.05*defCluster);
  const defClusterA = Math.min(safe(a.absDf,0),4);
  rawA *= (1 - 0.05*defClusterA);

  rawH *= 1 - clamp((safe(h.benchDepth,5)/10)*0.6,0,0.6) * 0.05;
  rawA *= 1 - clamp((safe(a.benchDepth,5)/10)*0.6,0,0.6) * 0.05;
  if(safe(h.newCoach,0)>=1) rawH *= 1.06; if(safe(a.newCoach,0)>=1) rawA *= 1.06;

  const h2hRaw = (h2hResults.value||'').toUpperCase().replace(/[^WDL]/g,'').slice(0,10);
  const h2hScore = h2hRaw ? (((h2hRaw.match(/W/g)||[]).length - (h2hRaw.match(/L/g)||[]).length) / Math.max(1,h2hRaw.length)) : 0;
  const momentum = 0.13*(h.form - a.form) + 0.05*h2hScore;
  rawH *= (1 + momentum); rawA *= (1 - momentum);

  const shiftH = (safe(h.g2h,0) + 1) / (safe(h.g1h,0) + 1);
  const shiftA = (safe(a.g2h,0) + 1) / (safe(a.g1h,0) + 1);
  if(shiftH>1.15) rawH *= 1.05; if(shiftH<0.85) rawH *= 0.96;
  if(shiftA>1.15) rawA *= 1.05; if(shiftA<0.85) rawA *= 0.96;

  const restAdj = d => clamp(1 - 0.03 * Math.max(0, 3 - d), 0.78, 1.02);
  const travelAdj = km => 1 - Math.min(0.18, Math.max(0, (km - 200) * 0.00016));
  rawH *= restAdj(safe(document.getElementById('daysRestHome').value,4)) * travelAdj(safe(document.getElementById('travelKmHome').value,30));
  rawA *= restAdj(safe(document.getElementById('daysRestAway').value,4)) * travelAdj(safe(document.getElementById('travelKmAway').value,30));

  if(safe(document.getElementById('rain').value,0)>=1){ rawH *= 0.96; rawA *= 0.96; }
  const crowdH = clamp(safe(document.getElementById('crowdHome').value,1),0.8,1.2);
  rawH *= crowdH;
  rawH *= 1 + (clamp(safe(document.getElementById('motHome').value,1)-1,-1,1) * 0.08);
  rawA *= 1 + (clamp(safe(document.getElementById('motAway').value,1)-1,-1,1) * 0.08);
  rawH *= clamp(safe(document.getElementById('coachHome').value,1),0.8,1.4);
  rawA *= clamp(safe(document.getElementById('coachAway').value,1),0.8,1.4);

  const parseList = s => s.toString().split(',').map(x=>x.trim()).filter(Boolean).map(x=>parseFloat(x)).filter(x=>!isNaN(x));
  const scoresH = parseList(document.getElementById('scoresHome').value);
  const scoresA = parseList(document.getElementById('scoresAway').value);
  const avgRecent = ((scoresH.length?mean(scoresH):safe(h.goals, NaN)) + (scoresA.length?mean(scoresA):safe(a.goals, NaN))) / 2;
  const leagueAvg = Math.max(0.6,(safe(h.xg,LEAGUE_PRIOR) + safe(a.xg,LEAGUE_PRIOR))/2);
  const trendFactor = 1 + 0.12*(avgRecent - leagueAvg);
  rawH *= trendFactor; rawA *= trendFactor;

  const volH = scoresH.length? Math.min(1.2, 0.08 + std(scoresH)/Math.max(0.1,mean(scoresH))) : 0.06;
  const volA = scoresA.length? Math.min(1.2, 0.08 + std(scoresA)/Math.max(0.1,mean(scoresA))) : 0.06;
  rawH *= (1 + 0.8*volH); rawA *= (1 + 0.8*volA);

  let quality=0; [h.xg,a.xg,h.sot,a.sot,h.cs,a.cs].forEach(v=>{ if(v && v>0) quality+=1; }); quality = quality/6;
  const shrinkW = clamp(0.55 + 0.4*quality,0.45,0.95);
  let lambdaH = shrinkW*rawH + (1-shrinkW)*LEAGUE_PRIOR;
  let lambdaA = shrinkW*rawA + (1-shrinkW)*LEAGUE_PRIOR;

  const avg = (lambdaH + lambdaA)/2;
  if(avg > 3.8){ lambdaH *= 0.85; lambdaA *= 0.85; } else if(avg > 2.6){ lambdaH *= 0.94; lambdaA *= 0.94; }
  lambdaH *= 0.995; lambdaA *= 0.995;

  return {lambdaH:Math.max(0.01,lambdaH), lambdaA:Math.max(0.01,lambdaA), atkH:Ha.attack, atkA:Aa.attack, defH:Hd, defA:Ad, volH, volA, trendFactor};
}

/* Monte Carlo with adaptive rho */
function sampleLogPoisson(lambdaH,lambdaA,rho,sigma){
  const z1 = randNormal(0,sigma);
  const z2 = rho*z1 + Math.sqrt(Math.max(0,1-rho*rho))*randNormal(0,sigma);
  const lH = Math.max(0.01, lambdaH * Math.exp(z1 - 0.5*sigma*sigma));
  const lA = Math.max(0.01, lambdaA * Math.exp(z2 - 0.5*sigma*sigma));
  return [poisson(lH), poisson(lA)];
}
function monteCarlo(lambdaH,lambdaA,rho,sigmaFactor,volFactor,runs){
  const freq={}, totals={}; let home=0,draw=0,away=0;
  const sigma = clamp(0.10 + sigmaFactor*0.28 + volFactor*0.14, 0.06, 1.1);
  for(let i=0;i<runs;i++){
    const [gh,ga] = sampleLogPoisson(lambdaH,lambdaA,rho,sigma);
    const k=`${gh}-${ga}`; freq[k]=(freq[k]||0)+1; totals[gh+ga]=(totals[gh+ga]||0)+1;
    if(gh>ga) home++; else if(gh===ga) draw++; else away++;
  }
  return {freq, totals, pHome:home/runs, pDraw:draw/runs, pAway:away/runs};
}

/* Market & Platt */
function impliedProb(odds){ if(!odds||odds<=0) return null; return 1/odds; }
function deltaPercent(open,now){ if(!open||!now) return null; return ((now-open)/open*100); }
function statusFromDelta(d){ if(d===null) return {label:'N/A'}; const ad=Math.abs(d); if(ad>=15) return {label:'Trap'}; if(ad>=5) return {label:'Warning'}; return {label:'Stable'}; }
function applyPlatt(p,a,b){ if(a===null||b===null||isNaN(a)||isNaN(b)) return p; const z=a + b*p; return 1/(1+Math.exp(-z)); }
function shrinkEdge(e){ if(e===null) return null; const cap=0.22; return Math.sign(e)*Math.min(Math.abs(e),cap); }

/* Confidence & calibration */
function computeConfidence(totals,candidates){
  let meanT=0,varv=0,count=0;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; meanT += g*v; count += v; }
  if(count===0) return {score:0.5,label:'Low'};
  meanT /= count;
  for(const t in totals){ const g=parseInt(t), v=totals[t]; varv += ((g-meanT)**2)*v; }
  varv /= count;
  let conf = clamp(1 - Math.min(1,varv/8), 0.15, 0.98);
  let traps=0; candidates.forEach(c=>{ if(c.status && c.status.label==='Trap') traps++; });
  if(traps>=2) conf *= 0.82;
  const allStable = candidates.every(c=> c.status && c.status.label==='Stable');
  if(allStable) conf = Math.min(0.995, conf*1.08);
  const label = conf>0.80? 'High' : (conf>0.55? 'Medium' : 'Low');
  return {score:conf,label};
}

/* Dynamic bias correction: use last 20 logs to compute ratio actual/predicted and adjust */
function dynamicBiasAdj(){
  try{
    const logs = JSON.parse(localStorage.getItem('v39_logs')||'[]');
    const recent = logs.slice(0,20);
    if(recent.length===0) return 1.0;
    let sumPred=0,sumAct=0,c=0;
    recent.forEach(r=>{ if(r.pred && r.pred.avgTotal && r.actual && typeof r.actual.total==='number'){ sumPred += r.pred.avgTotal; sumAct += r.actual.total; c++; } });
    if(c===0) return 1.0;
    const ratio = (sumAct / sumPred) || 1.0;
    return clamp(ratio, 0.8, 1.2);
  }catch(e){ return 1.0; }
}

/* Main analysis */
function analyzeV39(){
  const runs = Math.max(2000, safe(mcRuns.value,15000));
  // prepare team objects
  const h = { xg: safe(xgHome.value,1.1), sot: safe(sotHome.value,3.4), conv: clamp(safe(convHome.value,0.12),0,1), big: safe(bigHome.value,0), miss: safe(missHome.value,0), poss: safe(possHome.value,50), ti: safe(tiHome.value,25), cs: safe(csHome.value,0.32), gc: safe(gcHome.value,1.2), saves: safe(saveHome.value,3.6), err: safe(errHome.value,7), formRaw: formRawHome.value||'', form: Number.isFinite(parseFloat(formHome.value))? safe(formHome.value): null, absDf: safe(absDfHome.value,0), absMf: safe(absMfHome.value,0), absFw: safe(absFwHome.value,0), benchDepth: safe(benchHome.value,5), newCoach: safe(newCoachHome.value,0), need: safe(needHome.value,1), elo: safe(eloHome.value,1500), goals: safe(goalsHome.value,NaN), sqi: safe(sqiHome.value,1), spe: safe(speHome.value,0.5), ft: safe(ftHome.value,30), g1h: safe(g1hHome.value,0), g2h: safe(g2hHome.value,0)};
  const a = { xg: safe(xgAway.value,1.0), sot: safe(sotAway.value,3.0), conv: clamp(safe(convAway.value,0.11),0,1), big: safe(bigAway.value,0), miss: safe(missAway.value,0), poss: safe(possAway.value,48), ti: safe(tiAway.value,20), cs: safe(csAway.value,0.28), gc: safe(gcAway.value,1.3), saves: safe(saveAway.value,3.7), err: safe(errAway.value,8), formRaw: formRawAway.value||'', form: Number.isFinite(parseFloat(formAway.value))? safe(formAway.value): null, absDf: safe(absDfAway.value,0), absMf: safe(absMfAway.value,0), absFw: safe(absFwAway.value,0), benchDepth: safe(benchAway.value,5), newCoach: safe(newCoachAway.value,0), need: safe(needAway.value,1), elo: safe(eloAway.value,1480), goals: safe(goalsAway.value,NaN), sqi: safe(sqiAway.value,1), spe: safe(speAway.value,0.5), ft: safe(ftAway.value,28), g1h: safe(g1hAway.value,0), g2h: safe(g2hAway.value,0)};
  h.form = (Number.isFinite(h.form) && h.form>0)? clamp(h.form,0,1): (formScoreFromRaw(h.formRaw) || 0.5);
  a.form = (Number.isFinite(a.form) && a.form>0)? clamp(a.form,0,1): (formScoreFromRaw(a.formRaw) || 0.5);

  // dynamic bias adj
  const biasAdj = dynamicBiasAdj();

  // compute lambdas
  let r = computeLambdas(h,a);
  let lambdaH = r.lambdaH * biasAdj, lambdaA = r.lambdaA * biasAdj;

  // adaptive rho: based on vol & market
  const diffElo = Math.abs(safe(h.elo,1500)-safe(a.elo,1500));
  let rho = clamp(0.05 + 0.18 * (diffElo/800) + 0.12 * Math.abs(h.form - a.form), 0.03, 0.5);

  const sigmaFactor = clamp((Math.abs(h.form - a.form) + Math.abs(h.xg - a.xg))/4,0,1);
  const volFactor = clamp((r.volH + r.volA)/2,0,1);

  const mc = monteCarlo(lambdaH, lambdaA, rho, sigmaFactor, volFactor, runs);

  const avgH = Object.entries(mc.freq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[0])*v,0)/runs;
  const avgA = Object.entries(mc.freq).reduce((s,[sc,v])=>s + parseInt(sc.split('-')[1])*v,0)/runs;

  // OU & HDP probabilities and remaining UI update
  const ouLine = safe(ouLine.value,2.5);
  function probOUFromTotals(totals,line,runs){
    let over=0,under=0; const isInt = Number.isInteger(line);
    for(const t in totals){ const g=parseInt(t), v=totals[t]; if(isInt){ if(g>line) over+=v; else if(g<line) under+=v; else { over+=0.5*v; under+=0.5*v; } } else { if(g>line) over+=v; else under+=v; } }
    return {over: over/runs, under: under/runs};
  }
  const ouProb = probOUFromTotals(mc.totals, ouLine, runs);
  const hdpLine = safe(hdpLine.value,0.25);
  function probCoverFromScores(scoreFreq,handicap,runs){
    let win=0,push=0,lose=0;
    for(const sc in scoreFreq){ const v=scoreFreq[sc]; const [gh,ga]=sc.split('-').map(x=>parseInt(x)); const diff=gh-ga-handicap; if(diff>0) win+=v; else if(diff===0) push+=v; else lose+=v; }
    return (win + 0.5*push)/runs;
  }
  const coverHome = probCoverFromScores(mc.freq, hdpLine, runs);
  const coverAway = probCoverFromScores(mc.freq, -hdpLine, runs);

  // implied market probabilities
  const implied = { ouOver: impliedProb(safe(ouOverNow.value,NaN)), ouUnder: impliedProb(safe(ouUnderNow.value,NaN)), hdpHome: impliedProb(safe(hdpHomeNow.value,NaN)), hdpAway: impliedProb(safe(hdpAwayNow.value,NaN)) };

  // Platt scaling
  const plattA_over = Number(plattA_over.value) || null, plattB_over = Number(plattB_over.value) || null;
  const plattA_hdp = Number(plattA_hdp.value) || null, plattB_hdp = Number(plattB_hdp.value) || null;
  const model_over = applyPlatt(ouProb.over, plattA_over, plattB_over);
  const model_hdpHome = applyPlatt(coverHome, plattA_hdp, plattB_hdp);
  const model_hdpAway = applyPlatt(coverAway, plattA_hdp, plattB_hdp);

  // hybrid blend
  const conf = computeConfidence(mc.totals, [{market:'OU', open:safe(ouOverOpen.value,NaN), now:safe(ouOverNow.value,NaN)},{market:'HDP', open:safe(hdpHomeOpen.value,NaN), now:safe(hdpHomeNow.value,NaN)}]);
  const alpha = clamp(conf.score, 0.25, 0.92);
  const final_over = (implied.ouOver? (alpha*model_over + (1-alpha)*implied.ouOver) : model_over);
  const final_under = 1 - final_over;
  const final_hdpHome = (implied.hdpHome? (alpha*model_hdpHome + (1-alpha)*implied.hdpHome) : model_hdpHome);
  const final_hdpAway = (implied.hdpAway? (alpha*model_hdpAway + (1-alpha)*implied.hdpAway) : model_hdpAway);

  // edges & candidates
  const edges = { ouOver: (implied.ouOver? (final_over - implied.ouOver) : null), ouUnder: (implied.ouUnder? (final_under - implied.ouUnder) : null), hdpHome: (implied.hdpHome? (final_hdpHome - implied.hdpHome) : null), hdpAway: (implied.hdpAway? (final_hdpAway - implied.hdpAway) : null) };
  const candidates = [
    {tag:`OU Over ${ouLine}`, prob:final_over, edge:edges.ouOver, market:'OU', open:safe(ouOverOpen.value,NaN), now:safe(ouOverNow.value,NaN)},
    {tag:`OU Under ${ouLine}`, prob:final_under, edge:edges.ouUnder, market:'OU', open:safe(ouUnderOpen.value,NaN), now:safe(ouUnderNow.value,NaN)},
    {tag:`HDP Home ${hdpLine}`, prob:final_hdpHome, edge:edges.hdpHome, market:'HDP', open:safe(hdpHomeOpen.value,NaN), now:safe(hdpHomeNow.value,NaN)},
    {tag:`HDP Away ${-hdpLine}`, prob:final_hdpAway, edge:edges.hdpAway, market:'HDP', open:safe(hdpAwayOpen.value,NaN), now:safe(hdpAwayNow.value,NaN)}
  ];
  candidates.forEach(c=>{ c.edgeShr = (c.edge===null? null: shrinkEdge(c.edge)); c.delta = deltaPercent(c.open,c.now); c.status = statusFromDelta(c.delta); c.score = ((c.edgeShr||0)*(c.prob||0)) + (c.prob*0.62); c.direction = (c.open&&c.now)? (c.now < c.open? (c.market==='OU'?'Money → Over':'Money → Home') : (c.now > c.open? (c.market==='OU'?'Money → Under':'Money → Away') : 'Stable')) : ''; });
  candidates.sort((a,b)=>b.score - a.score);
  const selected = candidates.slice(0,2).map(c=>{ let signal='Low'; if(c.prob>=0.60 && c.edgeShr!==null && c.edgeShr>=0.015) signal='High'; else if(c.prob>=0.55 && c.edgeShr!==null && c.edgeShr>=0.01) signal='Medium'; return {...c,signal}; });

  // summary
  let summary = `λ (sharp, biasAdj ${biasAdj.toFixed(3)}): Home ${lambdaH.toFixed(2)} | Away ${lambdaA.toFixed(2)}\n`;
  summary += `Attack idx H:${r.atkH.toFixed(2)} A:${r.atkA.toFixed(2)} | Def idx H:${r.defH.toFixed(2)} A:${r.defA.toFixed(2)}\n`;
  summary += `Trend:${r.trendFactor.toFixed(2)} | Vol H/A:${(r.volH||0).toFixed(2)}/${(r.volA||0).toFixed(2)}\n`;
  summary += `Expected goals(sim): H ${avgH.toFixed(2)} | A ${avgA.toFixed(2)}\n`;
  summary += `Prob 1X2 — Home ${(100*mc.pHome).toFixed(1)}% Draw ${(100*mc.pDraw).toFixed(1)}% Away ${(100*mc.pAway).toFixed(1)}%\n`;
  summary += `OU(${ouLine}) → Over ${percent(final_over)} | Under ${percent(final_under)}\n`;
  summary += `HDP(${hdpLine}) → Home ${percent(final_hdpHome)} | Away ${percent(final_hdpAway)}\n`;
  summary += `Confidence: ${conf.label} (${(100*conf.score).toFixed(1)}%) • Model weight α=${alpha.toFixed(2)}\n`;
  document.getElementById('summary').textContent = summary;

  // render recommendations
  let html=''; selected.forEach(s=>{ const arrow = (s.signal==='High')? '📈' : (s.signal==='Medium'? '⚠️' : ''); html += `<div class="card"><div style="font-weight:700">${s.tag}</div><div class="small">${s.direction}</div><div style="float:right;text-align:right">${percent(s.prob)}<br>${s.edgeShr!==null?((s.edgeShr*100).toFixed(2)+'% edge'):'-'}<div style="margin-top:6px">${s.signal} ${arrow}</div></div><div style="clear:both"></div></div>`; });
  document.getElementById('bestRec').innerHTML = html || '<div class="small">Tidak ada rekomendasi signifikan.</div>';

  // trap table
  let table = '<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr>';
  candidates.forEach(c=>{ table += `<tr><td>${c.tag}</td><td>${c.open||''}</td><td>${c.now||''}</td><td>${c.delta?c.delta.toFixed(1)+'%':''}</td><td>${c.direction}</td><td>${percent(c.prob)}</td><td>${c.edgeShr!==null?((c.edgeShr*100).toFixed(2)+'%'):'-'}</td><td>${c.status.label}</td></tr>`; });
  document.getElementById('trapTable').innerHTML = table;

  // visuals
  drawHistogram(mc.totals, ouLine);
  drawGauge(conf);

  // store last prediction for evaluation
  window._lastPrediction = {lambdaH,lambdaA,avgH,avgA,pHome:mc.pHome,pDraw:mc.pDraw,pAway:mc.pAway,ou:{line:ouLine,over:final_over,under:final_under},hdp:{line:hdpLine,home:final_hdpHome,away:final_hdpAway},freq:mc.freq};

  // return for further use
  return {mc, candidates, conf, biasAdj};
}

/* Visuals */
function drawHistogram(totals, ouLine){
  try{
    const canvas=document.getElementById('histMC'); const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const keys=Object.keys(totals).map(x=>parseInt(x)).sort((a,b)=>a-b);
    if(keys.length===0) return;
    const maxV=Math.max(...keys.map(k=>totals[k]||0),1);
    const pad=20; const w=(canvas.width-pad*2)/Math.max(1,keys.length);
    keys.forEach((k,i)=>{ const v=totals[k]||0; const h=(v/maxV)*(canvas.height-60); ctx.fillStyle=(k<=ouLine)?'#3fa34d':'#de3f3f'; ctx.fillRect(pad+i*w,canvas.height-40-h,Math.max(6,w-6),h); ctx.fillStyle='#9fd6ee'; ctx.font='11px Arial'; ctx.fillText(String(k),pad+i*w,canvas.height-18); });
  }catch(e){} 
}
function drawGauge(conf){
  try{
    const canvas=document.getElementById('confGauge'); const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx=canvas.width/2, cy=canvas.height*0.85, r=Math.min(canvas.width,canvas.height)*0.34;
    ctx.beginPath(); ctx.lineWidth=14; ctx.strokeStyle='#082733'; ctx.arc(cx,cy,r,Math.PI,2*Math.PI,false); ctx.stroke();
    const val=clamp(conf.score,0,1), end= Math.PI + val*Math.PI;
    ctx.beginPath(); ctx.lineWidth=14; ctx.strokeStyle = val>0.8? '#2dd36f' : (val>0.55? '#f7b731' : '#eb3b5a'); ctx.arc(cx,cy,r,Math.PI,end,false); ctx.stroke();
    ctx.font='16px Arial'; ctx.fillStyle='#cfe8ff'; ctx.textAlign='center'; ctx.fillText((val*100).toFixed(1)+'%',cx,cy-r-6); ctx.font='12px Arial'; ctx.fillText(conf.label,cx,cy-r+12);
  }catch(e){} 
}

/* Evaluation log */
const LOG_KEY = 'v39_logs';
function saveLogEntry(pred, actual, meta){
  const logs = JSON.parse(localStorage.getItem(LOG_KEY)||'[]');
  logs.unshift({time:new Date().toISOString(), match:`${teamHome.value} vs ${teamAway.value}`, pred, actual, meta});
  if(logs.length>500) logs.pop();
  localStorage.setItem(LOG_KEY, JSON.stringify(logs));
  renderEvalLog();
}
function renderEvalLog(){
  const logs = JSON.parse(localStorage.getItem(LOG_KEY)||'[]');
  const el = document.getElementById('evalLog');
  if(logs.length===0){ el.textContent='Belum ada data.'; return; }
  let txt=''; logs.forEach(l=>{ txt += `${l.time} | ${l.match} | Pred:${JSON.stringify(l.pred)} | Act:${JSON.stringify(l.actual)}\n`; });
  el.textContent = txt;
}
function exportLogsCSV(){
  const logs = JSON.parse(localStorage.getItem(LOG_KEY)||'[]');
  if(logs.length===0){ alert('Tidak ada log untuk diekspor.'); return; }
  const header = ['time','match','pred','actual','meta']; const rows = logs.map(r=>[r.time, r.match, JSON.stringify(r.pred), JSON.stringify(r.actual), JSON.stringify(r.meta)]);
  const csv = [header.join(','), ...rows.map(r=> r.map(c=>`"${(String(c)).replace(/"/g,'""')}"`).join(','))].join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='v39_eval_log.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/* UI handlers and wiring */
document.getElementById('btnAnalyze').addEventListener('click', ()=>{ try{ const out = analyzeV39(); saveLogEntry(out, null, {note:'predicted'}); }catch(e){ alert('Error saat analisis: '+e.message); } });
document.getElementById('btnAutoCR').addEventListener('click', autoCR);
document.getElementById('btnAutoAvgGoals').addEventListener('click', autoAvgGoals);
document.getElementById('btnExample').addEventListener('click', ()=>{
  teamHome.value='Latvia'; teamAway.value='Andorra'; h2hResults.value='D,L,D'; xgHome.value=1.05; xgAway.value=0.45; sotHome.value=4.1; sotAway.value=1.8; scoresHome.value='1,0,2,1,2'; scoresAway.value='0,1,0,2,1'; convHome.value=''; convAway.value=''; bigHome.value=1; missHome.value=2; bigAway.value=0; missAway.value=1; possHome.value=56; possAway.value=44; tackleHome.value=18; interHome.value=8; tackleAway.value=12; interAway.value=6; autoTI(); csHome.value=0.30; csAway.value=0.10; gcHome.value=1.05; gcAway.value=1.8; saveHome.value=3.1; saveAway.value=2.5; errHome.value=6; errAway.value=5; formRawHome.value='W,D,L,W,D'; formRawAway.value='L,L,D,W,D'; formHome.value=''; formAway.value=''; absDfHome.value=0; absMfHome.value=1; absFwHome.value=0; absDfAway.value=1; absMfAway.value=0; absFwAway.value=0; benchHome.value=5; benchAway.value=3; needHome.value=1; needAway.value=1; newCoachHome.value=0; newCoachAway.value=0; sqiHome.value=1; sqiAway.value=0.9; speHome.value=0.45; speAway.value=0.4; ftHome.value=35; ftAway.value=25; g1hHome.value=6; g2hHome.value=10; g1hAway.value=3; g2hAway.value=4; daysRestHome.value=5; daysRestAway.value=2; travelKmHome.value=40; travelKmAway.value=480; hdpLine.value=0.25; hdpHomeOpen.value=1.90; hdpHomeNow.value=1.95; hdpAwayOpen.value=1.95; hdpAwayNow.value=1.85; ouLine.value=2.5; ouOverOpen.value=1.95; ouOverNow.value=1.88; ouUnderOpen.value=1.90; ouUnderNow.value=2.00; mcRuns.value=15000;
  alert('Contoh terisi. Klik Analisis v39 UltraAI.');
});
document.getElementById('btnReset').addEventListener('click', ()=>{ document.querySelectorAll('input').forEach(i=>{ if(i.type!=='button') i.value=''; if(i.type==='checkbox') i.checked=false; }); document.getElementById('summary').textContent='Direset.'; document.getElementById('bestRec').innerHTML='Hasil rekomendasi akan tampil di sini.'; document.getElementById('trapTable').innerHTML='<tr><th>Pasar</th><th>Open</th><th>Now</th><th>Δ%</th><th>Arah</th><th>Prob</th><th>Edge%</th><th>Status</th></tr>'; renderEvalLog(); const ctx=document.getElementById('histMC').getContext('2d'); ctx.clearRect(0,0,600,160); const ctx2=document.getElementById('confGauge').getContext('2d'); ctx2.clearRect(0,0,260,140); window._lastPrediction=null; });
document.getElementById('btnEnterActual').addEventListener('click', ()=>{
  const txt = document.getElementById('actualScore').value.trim();
  if(!txt){ alert('Masukkan hasil actual. Format: gh-ga (contoh 2-2)'); return; }
  const parts = txt.split('-').map(x=>parseInt(x.trim())); if(parts.length!==2||isNaN(parts[0])||isNaN(parts[1])){ alert('Format salah.'); return; }
  if(!window._lastPrediction){ alert('Belum ada prediksi. Klik Analisis dulu.'); return; }
  const actual = {gh:parts[0], ga:parts[1], total: parts[0]+parts[1]}; const pred = {avgH: window._lastPrediction.avgH, avgA: window._lastPrediction.avgA, avgTotal: (window._lastPrediction.avgH + window._lastPrediction.avgA)};
  saveLogEntry(pred, actual, {note:'actual_entered'});
  alert('Actual disimpan ke log evaluasi.');
});
document.getElementById('btnExportLog').addEventListener('click', exportLogsCSV);

renderEvalLog();
</script>
</body>
</html>
